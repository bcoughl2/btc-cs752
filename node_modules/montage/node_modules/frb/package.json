{
  "name": "frb",
  "version": "0.2.18",
  "description": "Functional reactive bindings",
  "keywords": [
    "functional",
    "reactive",
    "bindings",
    "observe",
    "change"
  ],
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal/"
  },
  "contributors": [
    {
      "name": "Kris Kowal",
      "email": "kris@cixar.com",
      "url": "http://github.com/kriskowal/"
    }
  ],
  "bugs": {
    "url": "http://github.com/kriskowal/frb/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/frb/raw/master/LICENSE.md"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/kriskowal/frb.git"
  },
  "main": "bindings",
  "dependencies": {
    "collections": "^1.2.1"
  },
  "devDependencies": {
    "jasmine-node": ">=1.13.1 <1.14.0",
    "pegjs": "git://github.com/dmajda/pegjs.git",
    "memwatch": "*"
  },
  "scripts": {
    "test": "jasmine-node spec",
    "build-parser": "pegjs --allowed-start-rules expression,sheet grammar.pegjs"
  },
  "readme": "<img src=\"frb.png\" align=\"right\" alt=\"FRB Logo\">\n\n[![Build Status](https://travis-ci.org/montagejs/frb.png?branch=master)](http://travis-ci.org/montagejs/frb)\n\n# Functional Reactive Bindings\n\nIn their simplest form, bindings provide the illusion that two objects\nhave the same property.  Changing the property on one object causes the\nsame change in the other.  This is useful for coordinating state between\nviews and models, among other entangled objects.  For example, if you\nenter text into a text field, the same text might be added to the\ncorresponding database record.\n\n```javascript\nbind(object, \"a.b\", {\"<->\": \"c.d\"});\n```\n\nFunctional Reactive Bindings go farther.  They can gracefully bind long\nproperty paths and the contents of collections.  They can also\nincrementally update the results of chains of queries including maps,\nflattened arrays, sums, and averages.  They can also add and remove\nelements from sets based on the changes to a flag.  FRB makes it easy to\nincrementally ensure consistent state.\n\n```javascript\nbind(company, \"payroll\", {\"<-\": \"departments.map{employees.sum{salary}}.sum()\"});\nbind(document, \"body.classList.has('dark')\", {\"<-\": \"darkMode\", source: viewModel});\n```\n\nFRB is built from a combination of powerful functional and generic\nbuilding blocks, making it reliable, easy to extend, and easy to\nmaintain.\n\n\n## Getting Started\n\n`frb` is a CommonJS package, with JavaScript modules suitable for use\nwith [Node.js][] on the server side or [Mr][] on the client side. \n\n```\n❯ npm install frb\n```\n\n\n\n\n## Tutorial\n\nIn this example, we bind `model.content` to `document.body.innerHTML`.\n\n```javascript\nvar bind = require(\"frb/bind\");\nvar model = {content: \"Hello, World!\"};\nvar cancelBinding = bind(document, \"body.innerHTML\", {\n    \"<-\": \"content\",\n    \"source\": model\n});\n```\n\nWhen a source property is bound to a target property, the target gets\nreassigned to the source any time the source changes.\n\n```javascript\nmodel.content = \"Farewell.\";\nexpect(document.body.innerHTML).toBe(\"Farewell.\");\n```\n\nBindings can be recursively detached from the objects they observe with\nthe returned cancel function.\n\n```javascript\ncancelBinding();\nmodel.content = \"Hello again!\"; // doesn't take\nexpect(document.body.innerHTML).toBe(\"Farewell.\");\n```\n\n### Two-way Bindings\n\nBindings can go one way or in both directions.  Declare one-way\nbindings with the ```<-``` property, and two-way bindings with the\n```<->``` property.\n\nIn this example, the \"foo\" and \"bar\" properties of an object will be\ninexorably intertwined.\n\n```javascript\nvar object = {};\nvar cancel = bind(object, \"foo\", {\"<->\": \"bar\"});\n\n// <-\nobject.bar = 10;\nexpect(object.foo).toBe(10);\n\n// ->\nobject.foo = 20;\nexpect(object.bar).toBe(20);\n```\n\n### Right-to-left\n\nNote that even with a two-way binding, the right-to-left binding\nprecedes the left-to-right.  In this example, \"foo\" and \"bar\" are bound\ntogether, but both have initial values.\n\n```javascript\nvar object = {foo: 10, bar: 20};\nvar cancel = bind(object, \"foo\", {\"<->\": \"bar\"});\nexpect(object.foo).toBe(20);\nexpect(object.bar).toBe(20);\n```\n\nThe right-to-left assignment of `bar` to `foo` happens first, so the\ninitial value of `foo` gets lost.\n\n### Properties\n\nBindings can follow deeply nested chains, on both the left and the right\nside.\n\nIn this example, we have two object graphs, `foo`, and `bar`, with the\nsame structure and initial values.  This binds `bar.a.b` to `foo.a.b`\nand also the other way around.\n\n```javascript\nvar foo = {a: {b: 10}};\nvar bar = {a: {b: 10}};\nvar cancel = bind(foo, \"a.b\", {\n    \"<->\": \"a.b\",\n    source: bar\n});\n// <-\nbar.a.b = 20;\nexpect(foo.a.b).toBe(20);\n// ->\nfoo.a.b = 30;\nexpect(bar.a.b).toBe(30);\n```\n\n### Structure changes\n\nChanges to the structure of either side of the binding are no matter.\nAll of the orphaned event listeners will automatically be canceled, and\nthe binders and observers will reattach to the new object graph.\n\nContinuing from the previous example, we store and replace the `a`\nobject from one side of the binding.  The old `b` property is now\norphaned, and the old `b` property adopted in its place.\n\n```javascript\nvar a = foo.a;\nexpect(a.b).toBe(30); // from before\n\nfoo.a = {}; // orphan a and replace\nfoo.a.b = 40;\n// ->\nexpect(bar.a.b).toBe(40); // updated\n\nbar.a.b = 50;\n// <-\nexpect(foo.a.b).toBe(50); // new one updated\nexpect(a.b).toBe(30); // from before it was orphaned\n```\n\n### Strings\n\nString concatenation is straightforward.\n\n```javascript\nvar object = {name: \"world\"};\nbind(object, \"greeting\", {\"<-\": \"'hello ' + name + '!'\"});\nexpect(object.greeting).toBe(\"hello world!\");\n```\n\n### Sum\n\nSome advanced queries are possible with one-way bindings from\ncollections.  FRB updates sums incrementally.  When values are added or\nremoved from the array, the sum of only those values is taken and added\nor removed from the last known sum.\n\n```javascript\nvar object = {array: [1, 2, 3]};\nbind(object, \"sum\", {\"<-\": \"array.sum()\"});\nexpect(object.sum).toEqual(6);\n```\n\n### Average\n\nThe arithmetic mean of a collection can be updated incrementally.  Each\ntime the array changes, the added and removed values adjust the last\nknown sum and count of values in the array.\n\n```javascript\nvar object = {array: [1, 2, 3]};\nbind(object, \"average\", {\"<-\": \"array.average()\"});\nexpect(object.average).toEqual(2);\n```\n\n### Rounding\n\nThe `round`, `floor`, and `ceil` methods operate on numbers and return\nthe nearest integer, the nearest integer toward -infinity, and the\nnearest integer toward infinity respectively.\n\n```javascript\nvar object = {number: -0.5};\nBindings.defineBindings(object, {\n    \"round\": {\"<-\": \"number.round()\"},\n    \"floor\": {\"<-\": \"number.floor()\"},\n    \"ceil\": {\"<-\": \"number.ceil()\"}\n});\nexpect(object.round).toBe(0);\nexpect(object.floor).toBe(-1);\nexpect(object.ceil).toBe(0);\n```\n\n### Last\n\nFRB provides an operator for watching the last value in an Array.\n\n```javascript\nvar array = [1, 2, 3];\nvar object = {array: array, last: null};\nBindings.defineBinding(object, \"last\", {\"<-\": \"array.last()\"});\nexpect(object.last).toBe(3);\n\narray.push(4);\nexpect(object.last).toBe(4);\n```\n\nWhen the dust settles, `array.last()` is equivalent to\n`array[array.length - 1]`, but the `last` observer guarantees that it\nwill not jitter between the ultimate value and null or the penultimate\nvalue of the collection.  With `array[array.length]`, the underlying may\nnot change its content and length atomically.\n\n```javascript\nvar changed = jasmine.createSpy();\nPropertyChanges.addOwnPropertyChangeListener(object, \"last\", changed);\narray.unshift(0);\narray.splice(3, 0, 3.5);\nexpect(object.last).toBe(4);\nexpect(changed).not.toHaveBeenCalled();\n\narray.pop();\nexpect(object.last).toBe(3);\n\narray.clear();\nexpect(object.last).toBe(null);\n```\n\n### Only\n\nFRB provides an `only` operator, which can either observe or bind the\nonly element of a collection.  The `only` observer watches a collection\nfor when there is only one value in that collection and emits that\nvalue..  If there are multiple values, it emits null.\n\n```javascript\nvar object = {array: [], only: null};\nBindings.defineBindings(object, {\n    only: {\"<->\": \"array.only()\"}\n});\n\nobject.array = [1];\nexpect(object.only).toBe(1);\n\nobject.array.pop();\nexpect(object.only).toBe(undefined);\n\nobject.array = [1, 2, 3];\nexpect(object.only).toBe(undefined);\n```\n\nThe `only` binder watches a value.  When the value is null, it does\nnothing.  Otherwise, it will update the bound collection such that it\nonly contains that value.  If the collection was empty, it adds the\nvalue.  Otherwise, if the collection did not have the value, it replaces\nthe collection's content with the one value.  Otherwise, it removes\neverything but the value it already contains.  Regardless of the means,\nthe end result is the same.  If the value is non-null, it will be the\nonly value in the collection.\n\n```javascript\nobject.only = 2;\nexpect(object.array.slice()).toEqual([2]);\n// Note that slice() is necessary only because the testing scaffold\n// does not consider an observable array equivalent to a plain array\n// with the same content\n\nobject.only = null;\nobject.array.push(3);\nexpect(object.array.slice()).toEqual([2, 3]);\n```\n\n### One\n\nLike the `only` operator, there is also a `one` operator.  The `one`\noperator will observe one value from a collection, whatever value is\neasiest to obtain.  For an array, it's the first value; for a sorted\nset, it's whatever value was most recently found or added; for a heap,\nit's whatever is on top.  However, if the collection is null, undefined,\nor empty, the result is `undefined`.\n\n```javascript\nvar object = {array: [], one: null};\nBindings.defineBindings(object, {\n    one: {\"<-\": \"array.one()\"}\n});\n\nexpect(object.one).toBe(undefined);\n\nobject.array.push(1);\nexpect(object.one).toBe(1);\n\n// Still there...\nobject.array.push(2);\nexpect(object.one).toBe(1);\n```\n\nUnlike `only`, `one` is not bindable.\n\n### Map\n\nYou can also create mappings from one array to a new array and an\nexpression to evaluate on each value.  The mapped array is bound once,\nand all changes to the source array are incrementally updated in the\ntarget array.\n\n```javascript\nvar object = {objects: [\n    {number: 10},\n    {number: 20},\n    {number: 30}\n]};\nbind(object, \"numbers\", {\"<-\": \"objects.map{number}\"});\nexpect(object.numbers).toEqual([10, 20, 30]);\nobject.objects.push({number: 40});\nexpect(object.numbers).toEqual([10, 20, 30, 40]);\n```\n\nAny function, like `sum` or `average`, can be applied to the result of a\nmapping.  The straight-forward path would be\n`objects.map{number}.sum()`, but you can use a block with any function\nas a short hand, `objects.sum{number}`.\n\n### Filter\n\nA filter block generates an incrementally updated array filter.  The\nresulting array will contain only those elements from the source array\nthat pass the test deescribed in the block.  As values of the source\narray are added, removed, or changed such that they go from passing to\nfailing or failing to passing, the filtered array gets incrementally\nupdated to include or exclude those values in their proper positions, as\nif the whole array were regenerated with `array.filter` by brute force.\n\n```javascript\nvar object = {numbers: [1, 2, 3, 4, 5, 6]};\nbind(object, \"evens\", {\"<-\": \"numbers.filter{!(%2)}\"});\nexpect(object.evens).toEqual([2, 4, 6]);\nobject.numbers.push(7, 8);\nobject.numbers.shift();\nobject.numbers.shift();\nexpect(object.evens).toEqual([4, 6, 8]);\n```\n\n### Scope\n\nIn a binding, there is always a value in scope.  It is the implicit\nvalue for looking up properties and for applying operators, like\nmethods.  The value in scope can be called out explicitly as `this`.  On\nthe left side, the value in scope is called the target, on the right it\nis called the source.\n\nEach scope has a `this` value and may have a parent scope.  Inside a\nmap block, like the `number` in `numbers.map{number}`, the value in\nscope is one of the numbers, and the value in the parent scope is an\nobject with a `numbers` property.  To access the value in a parent\nscope, use the parent scope operator, `^`.\n\nSuppose you have an object with `numbers` and `maxNumber` properties.\nIn this example, we bind a property, `smallNumbers` to an array of all\nthe `numbers` less than or equal to the `maxNumber`.\n\n```javascript\nvar object = Bindings.defineBindings({\n    numbers: [1, 2, 3, 4, 5],\n    maxNumber: 3\n}, {\n    smallNumbers: {\n        \"<-\": \"numbers.filter{this <= ^maxNumber}\"\n    }\n});\n```\n\nKeywords like `this` overlap with the notation normally used for\nproperties of `this`.  If an object has a `this` property, you may use\nthe notation `.this`, `this.this`, or `this['this']`.  `.this` is the\nnormal form.\n\n```javascript\nvar object = Bindings.defineBindings({\n    \"this\": 10\n}, {\n    that: {\"<-\": \".this\"}\n});\nexpect(object.that).toBe(object[\"this\"]);\n```\n\nThe only other FRB keywords that collide with propery names are `true`,\n`false`, and `null`, and the same technique for disambiguation applies.\n\n### Some and Every\n\nA `some` block incrementally tracks whether some of the values in a\ncollection meet a criterion.\n\n```javascript\nvar object = Bindings.defineBindings({\n    options: [\n        {checked: true},\n        {checked: false},\n        {checked: false}\n    ]\n}, {\n    anyChecked: {\n        \"<-\": \"options.some{checked}\"\n    }\n});\nexpect(object.anyChecked).toBe(true);\n```\n\nAn `every` block incrementally tracks whether all of the values in a\ncollection meet a criterion.\n\n```javascript\nvar object = Bindings.defineBindings({\n    options: [\n        {checked: true},\n        {checked: false},\n        {checked: false}\n    ]\n}, {\n    allChecked: {\n        \"<-\": \"options.every{checked}\"\n    }\n});\nexpect(object.allChecked).toBe(false);\n```\n\nYou can use a two-way binding on `some` and `every` blocks.\n\n```javascript\nvar object = Bindings.defineBindings({\n    options: [\n        {checked: true},\n        {checked: false},\n        {checked: false}\n    ]\n}, {\n    allChecked: {\n        \"<->\": \"options.every{checked}\"\n    },\n    noneChecked: {\n        \"<->\": \"!options.some{checked}\"\n    }\n});\n\nobject.noneChecked = true;\nexpect(object.options.every(function (option) {\n    return !option.checked\n}));\n\nobject.allChecked = true;\nexpect(object.noneChecked).toBe(false);\n```\n\nThe caveat of an `equals` binding applies.  If the condition for every\nelement of the collection is set to true, the condition will be bound\nincrementally to true on each element.  When the condition is set to\nfalse, the binding will simply be canceled.\n\n```javascript\nobject.allChecked = false;\nexpect(object.options.every(function (option) {\n    return option.checked; // still checked\n}));\n```\n\n### Sorted\n\nA sorted block generates an incrementally updated sorted array.  The\nresulting array will contain all of the values from the source except in\nsorted order.\n\n```javascript\nvar object = {numbers: [5, 2, 7, 3, 8, 1, 6, 4]};\nbind(object, \"sorted\", {\"<-\": \"numbers.sorted{}\"});\nexpect(object.sorted).toEqual([1, 2, 3, 4, 5, 6, 7, 8]);\n```\n\nThe block may specify a property or expression by which to compare\nvalues.\n\n```javascript\nvar object = {arrays: [[1, 2, 3], [1, 2], [], [1, 2, 3, 4], [1]]};\nbind(object, \"sorted\", {\"<-\": \"arrays.sorted{-length}\"});\nexpect(object.sorted.map(function (array) {\n    return array.slice(); // to clone\n})).toEqual([\n    [1, 2, 3, 4],\n    [1, 2, 3],\n    [1, 2],\n    [1],\n    []\n]);\n```\n\nThe sorted binding responds to changes to the sorted property by\nremoving them at their former place and adding them back at their new\nposition.\n\n```javascript\nobject.arrays[0].push(4, 5);\nexpect(object.sorted.map(function (array) {\n    return array.slice(); // to clone\n})).toEqual([\n    [1, 2, 3, 4, 5], // new\n    [1, 2, 3, 4],\n    // old\n    [1, 2],\n    [1],\n    []\n]);\n```\n\n### Unique and Sorted\n\nFRB can create a sorted index of unique values using `sortedSet` blocks.\n\n```javascript\nvar object = Bindings.defineBindings({\n    folks: [\n        {id: 4, name: \"Bob\"},\n        {id: 2, name: \"Alice\"},\n        {id: 3, name: \"Bob\"},\n        {id: 1, name: \"Alice\"},\n        {id: 1, name: \"Alice\"} // redundant\n    ]\n}, {\n    inOrder: {\"<-\": \"folks.sortedSet{id}\"},\n    byId: {\"<-\": \"folks.map{[id, this]}.toMap()\"},\n    byName: {\"<-\": \"inOrder.toArray().group{name}.toMap()\"}\n});\n\nexpect(object.inOrder.toArray()).toEqual([\n    object.byId.get(1),\n    object.byId.get(2),\n    object.byId.get(3),\n    object.byId.get(4)\n]);\n\nexpect(object.byName.get(\"Alice\")).toEqual([\n    object.byId.get(1),\n    object.byId.get(2)\n]);\n```\n\nThe outcome is a `SortedSet` data structure, not an `Array`.  The sorted\nset is useful for fast lookups, inserts, and deletes on sorted, unique\ndata.  If you would prefer a sorted array of unique values, you can\ncombine other operators to the same effect.\n\n```javascript\nvar object = Bindings.defineBindings({\n    folks: [\n        {id: 4, name: \"Bob\"},\n        {id: 2, name: \"Alice\"},\n        {id: 3, name: \"Bob\"},\n        {id: 1, name: \"Alice\"},\n        {id: 1, name: \"Alice\"} // redundant\n    ]\n}, {\n    index: {\"<-\": \"folks.group{id}.sorted{.0}.map{.1.last()}\"}\n});\n\nexpect(object.index).toEqual([\n    {id: 1, name: \"Alice\"},\n    {id: 2, name: \"Alice\"},\n    {id: 3, name: \"Bob\"},\n    {id: 4, name: \"Bob\"}\n]);\n```\n\n\n### Min and Max\n\nA binding can observe the minimum or maximum of a collection.  FRB uses\na binary heap internally to incrementally track the minimum or maximum\nvalue of the collection.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    min: {\"<-\": \"values.min()\"},\n    max: {\"<-\": \"values.max()\"}\n});\n\nexpect(object.min).toBe(undefined);\nexpect(object.max).toBe(undefined);\n\nobject.values = [2, 3, 2, 1, 2];\nexpect(object.min).toBe(1);\nexpect(object.max).toBe(3);\n\nobject.values.push(4);\nexpect(object.max).toBe(4);\n```\n\nMin and max blocks accept an expression on which to compare values from\nthe collection.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    loser: {\"<-\": \"rounds.min{score}.player\"},\n    winner: {\"<-\": \"rounds.max{score}.player\"}\n});\n\nobject.rounds = [\n    {score: 0, player: \"Luke\"},\n    {score: 100, player: \"Obi Wan\"},\n    {score: 250, player: \"Vader\"}\n];\nexpect(object.loser).toEqual(\"Luke\");\nexpect(object.winner).toEqual(\"Vader\");\n\nobject.rounds[1].score = 300;\nexpect(object.winner).toEqual(\"Obi Wan\");\n```\n\n### Group\n\nFRB can incrementally track equivalence classes within in a collection.\nThe group block accepts an expression that determines the equivalence\nclass for each object in a collection.  The result is a nested data\nstructure: an array of [key, class] pairs, where each class is itself an\narray of all members of the collection that have the corresponding key.\n\n```javascript\nvar store = Bindings.defineBindings({}, {\n    \"clothingByColor\": {\"<-\": \"clothing.group{color}\"}\n});\nstore.clothing = [\n    {type: 'shirt', color: 'blue'},\n    {type: 'pants', color: 'red'},\n    {type: 'blazer', color: 'blue'},\n    {type: 'hat', color: 'red'}\n];\nexpect(store.clothingByColor).toEqual([\n    ['blue', [\n        {type: 'shirt', color: 'blue'},\n        {type: 'blazer', color: 'blue'}\n    ]],\n    ['red', [\n        {type: 'pants', color: 'red'},\n        {type: 'hat', color: 'red'}\n    ]]\n]);\n```\n\nTracking the positions of every key and every value in its equivalence\nclass can be expensive.  Internally, `group` blocks are implemented with\na `groupMap` block followed by an `entries()` observer.  The `groupMap`\nproduces a `Map` data structure and does not waste any time, but does\nnot produce range change events.  The `entries()` observer projects the\nmap of classes into the nested array data structure.\n\nYou can use the `groupMap` block directly.\n\n```javascript\nBindings.cancelBinding(store, \"clothingByColor\");\nBindings.defineBindings(store, {\n    \"clothingByColor\": {\"<-\": \"clothing.groupMap{color}\"}\n});\nvar blueClothes = store.clothingByColor.get('blue');\nexpect(blueClothes).toEqual([\n    {type: 'shirt', color: 'blue'},\n    {type: 'blazer', color: 'blue'}\n]);\n\nstore.clothing.push({type: 'gloves', color: 'blue'});\nexpect(blueClothes).toEqual([\n    {type: 'shirt', color: 'blue'},\n    {type: 'blazer', color: 'blue'},\n    {type: 'gloves', color: 'blue'}\n]);\n```\n\nThe `group` and `groupMap` blocks both respect the type of the source\ncollection.  If instead of an array you were to use a `SortedSet`, the\nequivalence classes would each be sorted sets.  This is useful because\nreplacing values in a sorted set can be performed with much less waste\nthan with a large array.\n\n### View\n\nSuppose that your source is a large data store, like a `SortedSet` from\nthe [Collections][] package.  You might need to view a sliding window\nfrom that collection as an array.  The `view` binding reacts to changes\nto the collection and the position and length of the window.\n\n```javascript\nvar SortedSet = require(\"collections/sorted-set\");\nvar controller = {\n    index: SortedSet([1, 2, 3, 4, 5, 6, 7, 8]),\n    start: 2,\n    length: 4\n};\nvar cancel = bind(controller, \"view\", {\n    \"<-\": \"index.view(start, length)\"\n});\n\nexpect(controller.view).toEqual([3, 4, 5, 6]);\n\n// change the window length\ncontroller.length = 3;\nexpect(controller.view).toEqual([3, 4, 5]);\n\n// change the window position\ncontroller.start = 5;\nexpect(controller.view).toEqual([6, 7, 8]);\n\n// add content behind the window\ncontroller.index.add(0);\nexpect(controller.view).toEqual([5, 6, 7]);\n```\n\n### Enumerate\n\nAn enumeration observer produces `[index, value]` pairs.  You can bind\nto the index or the value in subsequent stages.  The prefix dot\ndistinguishes the zeroeth property from the literal zero.\n\n```javascript\nvar object = {letters: ['a', 'b', 'c', 'd']};\nbind(object, \"lettersAtEvenIndexes\", {\n    \"<-\": \"letters.enumerate().filter{!(.0 % 2)}.map{.1}\"\n});\nexpect(object.lettersAtEvenIndexes).toEqual(['a', 'c']);\nobject.letters.shift();\nexpect(object.lettersAtEvenIndexes).toEqual(['b', 'd']);\n```\n\n### Range\n\nA range observes a given length and produces and incrementally updates\nan array of consecutive integers starting with zero with that given\nlength.\n\n```javascript\nvar object = Bindings.defineBinding({}, \"stack\", {\n    \"<-\": \"&range(length)\"\n});\nexpect(object.stack).toEqual([]);\n\nobject.length = 3;\nexpect(object.stack).toEqual([0, 1, 2]);\n\nobject.length = 1;\nexpect(object.stack).toEqual([0]);\n```\n\n### Flatten\n\nYou can flatten nested arrays.  In this example, we have an array of\narrays and bind it to a flat array.\n\n```javascript\nvar arrays = [[1, 2, 3], [4, 5, 6]];\nvar object = {};\nbind(object, \"flat\", {\n    \"<-\": \"flatten()\",\n    source: arrays\n});\nexpect(object.flat).toEqual([1, 2, 3, 4, 5, 6]);\n```\n\nNote that changes to the inner and outer arrays are both projected into\nthe flattened array.\n\n```javascript\narrays.push([7, 8, 9]);\narrays[0].unshift(0);\nexpect(object.flat).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n```\n\nAlso, as with all other bindings that produce arrays, the flattened\narray is never replaced, just incrementally updated.\n\n```javascript\nvar flat = object.flat;\narrays.splice(0, arrays.length);\nexpect(object.flat).toBe(flat); // === same object\n```\n\n### Concat\n\nYou can observe the concatenation of collection of dynamic arrays.\n\n```javascript\nvar object = Bindings.defineBinding({\n    head: 10,\n    tail: [20, 30]\n}, \"flat\", {\n    \"<-\": \"[head].concat(tail)\"\n});\nexpect(object.flat).toEqual([10, 20, 30]);\n```\n\nThe underlying mechanism is equivalent to `[[head], tail].flatten()`.\n\n### Reversed\n\nYou can bind the reversal of an array.\n\n```javascript\nvar object = {forward: [1, 2, 3]};\nbind(object, \"backward\", {\n    \"<->\": \"forward.reversed()\"\n});\nexpect(object.backward.slice()).toEqual([3, 2, 1]);\nobject.forward.push(4);\nexpect(object.forward.slice()).toEqual([1, 2, 3, 4]);\nexpect(object.backward.slice()).toEqual([4, 3, 2, 1]);\n```\n\nNote that you can do two-way bindings, ```<->``` with reversed arrays.\nChanges to either side are updated to the opposite side.\n\n```javascript\nobject.backward.pop();\nexpect(object.backward.slice()).toEqual([4, 3, 2]);\nexpect(object.forward.slice()).toEqual([2, 3, 4]);\n```\n\n### Has\n\nYou can bind a property to always reflect whether a collection contains\na particular value.\n\n```javascript\nvar object = {\n    haystack: [1, 2, 3],\n    needle: 3\n};\nbind(object, \"hasNeedle\", {\"<-\": \"haystack.has(needle)\"});\nexpect(object.hasNeedle).toBe(true);\nobject.haystack.pop(); // 3 comes off\nexpect(object.hasNeedle).toBe(false);\n```\n\nThe binding also reacts to changes to the value you seek.\n\n```javascript\n// Continued from above...\nobject.needle = 2;\nexpect(object.hasNeedle).toBe(true);\n```\n\n`has` bindings are not incremental, but with the right data-structure,\nupdates are cheap.  The [Collections][] package contains Lists, Sets,\nand OrderedSets that all can send ranged content change notifications and thus\ncan be bound.\n\n```javascript\n// Continued from above...\nvar Set = require(\"collections/set\");\nobject.haystack = new Set([1, 2, 3]);\nexpect(object.hasNeedle).toBe(true);\n```\n\nLikewise, Maps implement `addMapChangeListener`, so you can use a `has` binding\nto observe whether an entry exists with the given key.\n\n```javascript\n// Continued from above...\nvar Map = require(\"collections/map\");\nobject.haystack = new Map([[1, \"a\"], [2, \"b\"]]);\nobject.needle = 2;\nexpect(object.hasNeedle).toBe(true);\nobject.needle = 3;\nexpect(object.hasNeedle).toBe(false);\n```\n\n`has` bindings can also be left-to-right and bi-directional.\n\n```javascript\nbind(object, \"hasNeedle\", {\"<->\": \"haystack.has(needle)\"});\nobject.hasNeedle = false;\nexpect(object.haystack.has(2)).toBe(false);\n```\n\nThe collection on the left-hand-side must implement `has` or `contains`,\n`add`, and `delete` or `remove`.  FRB shims `Array` to have `has`,\n`add`, and `delete`, just like all the collections in [Collections][].\nIt happens that the `classList` properties of DOM elements, when they\nare supported, implement `add`, `remove`, and `contains`.\n\n```javascript\nvar model = {darkMode: false};\nbind(document.body, \"classList.has('dark')\", {\n    \"<-\": \"darkMode\",\n    source: model\n});\n```\n\nThe DOM `classList` does not however implement\n`addRangeChangeListener` or `removeRangeChangeListener`, so it\ncannot be used on the right-hand-side of a binding, and such bindings\ncannot be bidirectional.  With some DOM [Mutation Observers][], you\nmight be able to help FRB overcome this limitation in the future.\n\n### Get\n\nA binding can observe changes in key-to-value mappings in arrays and map\n[Collections][].\n\n```javascript\nvar object = {\n    array: [1, 2, 3],\n    second: null\n};\nvar cancel = bind(object, \"second\", {\n    \"<->\": \"array.get(1)\"\n});\nexpect(object.array.slice()).toEqual([1, 2, 3]);\nexpect(object.second).toBe(2);\n\nobject.array.shift();\nexpect(object.array.slice()).toEqual([2, 3]);\nexpect(object.second).toBe(3);\n\nobject.second = 4;\nexpect(object.array.slice()).toEqual([2, 4]);\n\ncancel();\nobject.array.shift();\nexpect(object.second).toBe(4); // still\n```\n\nThe source collection can be a Map, Dict, MultiMap, SortedMap,\nSortedArrayMap, or anything that implements `get` and\n`addMapChangeListener` as specified in [Collections][].  The key can\nalso be a variable.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar a = {id: 0}, b = {id: 1};\nvar object = {\n    source: Map([[a, 10], [b, 20]]),\n    key: null,\n    selected: null\n};\n\nvar cancel = bind(object, \"selected\", {\n    \"<-\": \"source.get(key)\"\n});\nexpect(object.selected).toBe(undefined);\n\nobject.key = a;\nexpect(object.selected).toBe(10);\n\nobject.key = b;\nexpect(object.selected).toBe(20);\n\nobject.source.set(b, 30);\nexpect(object.selected).toBe(30);\n\nvar SortedMap = require(\"collections/sorted-map\");\nobject.source = SortedMap();\nexpect(object.selected).toBe(undefined);\n\nobject.source.set(b, 40);\nexpect(object.selected).toBe(40);\n\ncancel();\nobject.key = a; // no effect\nexpect(object.selected).toBe(40);\n```\n\nYou can also bind the entire content of a map-like collection to the\ncontent of another.  Bear in mind that the content of the source\nreplaces the content of the target initially.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar object = {\n    a: Map({a: 10}),\n    b: Map()\n};\nvar cancel = bind(object, \"a.mapContent()\", {\"<->\": \"b.mapContent()\"});\nexpect(object.a.toObject()).toEqual({});\nexpect(object.b.toObject()).toEqual({});\n\nobject.a.set('a', 10);\nexpect(object.a.toObject()).toEqual({a: 10});\nexpect(object.b.toObject()).toEqual({a: 10});\n\nobject.b.set('b', 20);\nexpect(object.a.toObject()).toEqual({a: 10, b: 20});\nexpect(object.b.toObject()).toEqual({a: 10, b: 20});\n```\n\nIn this case, the source of the binding is a different object than the\ntarget, so the binding descriptor specifies the alternate source.\n\n### Keys, Values, Entries\n\nIf the source of a binding is a map, FRB can also translate changes to\nthe map into changes on an array.  The `keys`, `values`, and `entries`\nobservers produce incrementally updated projections of the\nkey-value-mappings onto an array.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar object = Bindings.defineBindings({}, {\n    keys: {\"<-\": \"map.keys()\"},\n    values: {\"<-\": \"map.values()\"},\n    entries: {\"<-\": \"map.entries()\"}\n});\nobject.map = Map({a: 10, b: 20, c: 30});\nexpect(object.keys).toEqual(['a', 'b', 'c']);\nexpect(object.values).toEqual([10, 20, 30]);\nexpect(object.entries).toEqual([['a', 10], ['b', 20], ['c', 30]]);\n\nobject.map.set('d', 40);\nobject.map.delete('a');\nexpect(object.keys).toEqual(['b', 'c', 'd']);\nexpect(object.values).toEqual([20, 30, 40]);\nexpect(object.entries).toEqual([['b', 20], ['c', 30], ['d', 40]]);\n```\n\n### Coerce to Map\n\nRecords (Objects with a fixed shape), arrays of entries, and Maps\nthemselves can be coerced to an incrementally updated `Map` with the\n`toMap` operator.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    map: {\"<-\": \"entries.toMap()\"}\n});\n\n// map property will persist across changes to entries\nvar map = object.map;\nexpect(map).not.toBe(null);\n\nobject.entries = {a: 10};\nexpect(map.keys()).toEqual(['a']);\nexpect(map.has('a')).toBe(true);\nexpect(map.get('a')).toBe(10);\n```\n\nThe `toMap` observer maintains the insertion order of the keys.\n\n```javascript\n// Continued...\nobject.entries = [['b', 20], ['c', 30]];\nexpect(map.keys()).toEqual(['b', 'c']);\n\nobject.entries.push(object.entries.shift());\nexpect(map.keys()).toEqual(['c', 'b']);\n```\n\nIf the entries do not have unique keys, the last entry wins.  This is\nmanaged internally by observing, `entries.group{.0}.map{.1.last()}`.\n\n```javascript\n// Continued...\nobject.entries = [['a', 10], ['a', 20]];\nexpect(map.get('a')).toEqual(20);\nobject.entries.pop();\nexpect(map.get('a')).toEqual(10);\n```\n\n`toMap` binds the content of the output map to the content of the input\nmap and will clear and repopulate the output map if the input map is\nreplaced.\n\n```\n// Continued...\nobject.entries = new Map({a: 10});\nexpect(map.keys()).toEqual(['a']);\n```\n\n### Equals\n\nYou can bind to whether expressions are equal.\n\n```javascript\nvar fruit = {apples: 1, oranges: 2};\nbind(fruit, \"equal\", {\"<-\": \"apples == oranges\"});\nexpect(fruit.equal).toBe(false);\nfruit.orange = 1;\nexpect(fruit.equal).toBe(true);\n```\n\nEquality can be bound both directions.  In this example, we do a two-way\nbinding between whether a radio button is checked and a corresponding\nvalue in our model.\n\n```javascript\nvar component = {\n    orangeElement: {checked: false},\n    appleElement: {checked: true}\n};\nBindings.defineBindings(component, {\n    \"orangeElement.checked\": {\"<->\": \"fruit == 'orange'\"},\n    \"appleElement.checked\": {\"<->\": \"fruit == 'apple'\"},\n});\n\ncomponent.orangeElement.checked = true;\nexpect(component.fruit).toEqual(\"orange\");\n\ncomponent.appleElement.checked = true;\nexpect(component.fruit).toEqual(\"apple\");\n```\n\nBecause equality and assignment are interchanged in this language, you\ncan use either `=` or `==`.\n\nFRB also supports a comparison operator, `<=>`, which uses\n`Object.compare` to determines how two operands should be sorted in\nrelation to each other.\n\n### Array and Map Content\n\nIn JavaScript, arrays behave both like objects (in the sense that every\nindex is a property, but also like a map collection of index-to-value\npairs.  The [Collections][] package goes so far as to patch up the\n`Array` prototype so arrays can masquerade as maps, with the caveat that\n`delete(value)` behaves like a Set instead of a Map.\n\nThis duplicity is reflected in FRB.  You can access the values in an\narray using the object property notation or the mapped key notation.\n\n```javascript\nvar object = {\n    array: [1, 2, 3]\n};\nBindings.defineBindings(object, {\n    first: {\"<-\": \"array.0\"},\n    second: {\"<-\": \"array.get(1)\"}\n});\nexpect(object.first).toBe(1);\nexpect(object.second).toBe(2);\n```\n\nTo distinguish a numeric property of the source from a number literal,\nuse a dot.  To distingish a mapped index from an array literal, use an\nempty expression.\n\n```javascript\nvar array = [1, 2, 3];\nvar object = {};\nBindings.defineBindings(object, {\n    first: {\n        \"<-\": \".0\",\n        source: array\n    },\n    second: {\n        \"<-\": \"get(1)\",\n        source: array\n    }\n});\nexpect(object.first).toBe(1);\nexpect(object.second).toBe(2);\n```\n\nUnlike property notation, map notation can observe a variable index.\n\n```javascript\nvar object = {\n    array: [1, 2, 3],\n    index: 0\n};\nBindings.defineBinding(object, \"last\", {\n    \"<-\": \"array.get(array.length - 1)\"\n});\nexpect(object.last).toBe(3);\n\nobject.array.pop();\nexpect(object.last).toBe(2);\n```\n\nYou can also bind *all* of the content of an array by range or by\nmapping.  The notation for binding ranged content is `rangeContent()`.\nEvery change to an Array or SortedSet dispatches range changes and any\ncollection that implements `splice` and `swap` can be a target for such\nchanges.\n\n```javascript\nvar SortedSet = require(\"collections/sorted-set\");\nvar object = {\n    set: SortedSet(),\n    array: []\n};\nBindings.defineBindings(object, {\n    \"array.rangeContent()\": {\"<-\": \"set\"}\n});\nobject.set.addEach([5, 2, 6, 1, 4, 3]);\nexpect(object.array).toEqual([1, 2, 3, 4, 5, 6]);\n```\n\nThe notation for binding the content of any mapping collection using map\nchanges is `mapContent()`.  On the target of a binding, this will note\nwhen values are added or removed on each key of the source collection\nand apply the same change to the target.  The target and source can be\narrays or map collections.\n\n```javascript\nvar Map = require(\"collections/map\");\nvar object = {\n    map: Map(),\n    array: []\n};\nBindings.defineBinding(object, \"map.mapContent()\", {\n    \"<-\": \"array\"\n});\nobject.array.push(1, 2, 3);\nexpect(object.map.toObject()).toEqual({\n    0: 1,\n    1: 2,\n    2: 3\n});\n```\n\n### Value\n\nA note about the source value: an empty path implies the source value.\nUsing empty paths and empty expressions is useful in some situations.\n\nIf a value is ommitted on either side of an operator, it implies the\nsource value.  The expression `sorted{}` indicates a sorted array, where\neach value is sorted by its own numeric value.  The expression\n`filter{!!}` would filter falsy values.  The operand is implied.\nSimilarly, `filter{!(%2)}` produces only even values.\n\nThis is why you can use `.0` to get the zeroth property of an array, to\ndistingiush the form from `0` which would be a numeric literal, and why\nyou can use `()[0]` to map the zeroeth key of a map or array, to\ndistinguish the form from `[0]` which would be an array literal.\n\n### With Context Value\n\nExpressions can be evaluated in the context of another value using a\nvariant of property notation.  A parenthesized expression can follow a\npath.\n\n```javascript\nvar object = {\n    context: {a: 10, b: 20}\n};\nBindings.defineBinding(object, \"sum\", {\n    \"<-\": \"context.(a + b)\"\n});\nexpect(object.sum).toBe(30);\n\nBindings.cancelBinding(object, \"sum\");\nobject.context.a = 20;\nexpect(object.sum).toBe(30); // unchanged\n```\n\nTo observe a constructed array or object literal, the expression does\nnot need parentheses.\n\n```javascript\nvar object = {\n    context: {a: 10, b: 20}\n};\nBindings.defineBindings(object, {\n    \"duple\": {\"<-\": \"context.[a, b]\"},\n    \"pair\": {\"<-\": \"context.{key: a, value: b}\"}\n});\nexpect(object.duple).toEqual([10, 20]);\nexpect(object.pair).toEqual({key: 10, value: 20});\n\nBindings.cancelBindings(object);\n```\n\n### Operators\n\nFRB can also recognize many operators.  These are in order of precedence\nunary `-` negation, `+` numeric coercion, and `!` logical negation and\nthen binary `**` power, `//` root, `%%` logarithm, `*`, `/`, `%` modulo,\n`%%` remainder, `+`, `-`, ```<```, ```>```, ```<=```, ```>=```, `=` or\n`==`, `!=`, `&&` and `||`.\n\n```javascript\nvar object = {height: 10};\nbind(object, \"heightPx\", {\"<-\": \"height + 'px'\"});\nexpect(object.heightPx).toEqual(\"10px\");\n```\n\nThe unary `+` operator coerces a value to a number. It is handy for\nbinding a string to a number.\n\n```javascript\nvar object = {\n    number: null,\n    string: null,\n};\nBindings.defineBinding(object, \"+number\", {\n    \"<-\": \"string\"\n});\nobject.string = '10';\nexpect(object.number).toBe(10);\n```\n\n### Functions\n\nFRB supports some common functions.  `startsWith`, `endsWith`, and\n`contains` all operate on strings.  `join` concatenates an array of\nstrings with a given delimiter (or empty string).  `split` breaks a\nstring between every delimiter (or just between every character).\n`join` and `split` are algebraic and can be bound as well as observed.\n\n### Conditional\n\nFRB supports the ternary conditional operator, if `?` then `:` else.\n\n```javascript\nvar object = Bindings.defineBindings({\n    condition: null,\n    consequent: 10,\n    alternate: 20\n}, {\n    choice: {\"<->\": \"condition ? consequent : alternate\"}\n});\n\nexpect(object.choice).toBe(undefined); // no choice made\n\nobject.condition = true;\nexpect(object.choice).toBe(10);\n\nobject.condition = false;\nexpect(object.choice).toBe(20);\n```\n\nThe ternary operator can bind in both directions.\n\n```javascript\nobject.choice = 30;\nexpect(object.alternate).toBe(30);\n\nobject.condition = true;\nobject.choice = 40;\nexpect(object.consequent).toBe(40);\n```\n\n### And\n\nThe logical **and** operator, `&&`, observes either the left or right\nargument depending on whether the first argument is both defined and\ntrue.  If the first argument is null, undefined, or false, it will stand\nfor the whole expression.  Otherwise, the second argument will stand for\nthe whole expression.\n\nIf we assume that the first and second argument are always defined and\neither true or false, the **and** operator serves strictly as a logical\ncombinator.  However, with bindings, it is common for a value to at\nleast initially be null or undefined.  Logical operators are the\nexception to the rule that an expression will necessarily terminate if\nany operand is null or undefined.\n\nIn this example, the left and right sides are initially undefined.  We\nset the right operand to `10` and the bound value remains undefined.\n\n```javascript\nvar object = Bindings.defineBindings({\n    left: undefined,\n    right: undefined\n}, {\n    and: {\"<-\": \"left && right\"}\n});\n\nobject.right = 10;\nexpect(object.and).toBe(undefined);\n```\n\nWe set the left operand to `20`.  The bound value becomes the value of\nthe right operand, `10`.\n\n```javascript\n// Continued...\nobject.left = 20;\nexpect(object.and).toBe(10);\n```\n\n---\n\nInterestingly, logical **and** is bindable.  The objective of the\nbinding is to do whatever is necessary, if possible, to make the logical\nexpression equal the bound value.\n\nSupposing that both the left and right operands are false, and the\nresult is or becomes true, to satisfy the equality `left && right ==\ntrue`, both left and right must be set and bound to `true`.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    \"left && right\": {\n        \"<-\": \"leftAndRight\"\n    }\n});\n\nobject.leftAndRight = true;\nexpect(object.left).toBe(true);\nexpect(object.right).toBe(true);\n```\n\nAs with the equals binder, logic bindings will prefer to alter the left\noperand if altering either operand would suffice to validate the\nexpression.  So, if the expression then becomes false, it is sufficient\nto set the left side to false to satisfy the equality.\n\n```javascript\n// Continued...\nobject.leftAndRight = false;\nexpect(object.left).toBe(false);\nexpect(object.right).toBe(true);\n```\n\nThis can facilitate some interesting, tri-state logic.  For example, if\nyou have a checkbox that can be checked, unchecked, or disabled, and you\nwant it to be unchecked if it is disabled, you can use logic bindings to\nensure this.\n\n```javascript\nvar controller = Bindings.defineBindings({\n    checkbox: {\n        checked: false,\n        disabled: false\n    },\n    model: {\n        expanded: false,\n        children: [1, 2, 3]\n    }\n}, {\n    \"checkbox.checked\": {\"<->\": \"model.expanded && expandable\"},\n    \"checkbox.disabled\": {\"<-\": \"!expandable\"},\n    \"expandable\": {\"<-\": \"model.children.length > 0\"}\n});\n\nexpect(controller.checkbox.checked).toBe(false);\nexpect(controller.checkbox.disabled).toBe(false);\n\n// check the checkbox\ncontroller.checkbox.checked = true;\nexpect(controller.model.expanded).toBe(true);\n\n// alter the model such that the checkbox is unchecked and disabled\ncontroller.model.children.clear();\nexpect(controller.checkbox.checked).toBe(false);\nexpect(controller.checkbox.disabled).toBe(true);\n```\n\n### Or\n\nAs with the **and** operator, the logical **or** is an exception to the\nrule that an expression is null, undefined, or empty if any of the\noperands are null or undefined.  If both operands are defined and\nboolean, **or** expressions behave strictly within the realm of logic.\nHowever, if the values are non-boolean or even non-values, they serve to\nselect either the left or right side based on whether the left side is\ndefined and true.\n\nIf the first argument is undefined or false, the aggregate expression\nwill evaluate to the second argument, even if that argument is null or\nundefined.\n\nSuppose we bind `or` to `left || right` on some object.  `or` will be\n`undefined` initially, but if we set the `right` to `10`, `or` will\nbecome `10`, bypassing the still undefined left side.\n\n```javascript\nvar object = Bindings.defineBindings({\n    left: undefined,\n    right: undefined\n}, {\n    or: {\"<-\": \"left || right\"}\n});\n\nobject.right = 10;\nexpect(object.or).toBe(10);\n```\n\nHowever, the left hand side takes precedence over the right if it is\ndefined and true.\n\n```javascript\n// Continued...\nobject.left = 20;\nexpect(object.or).toBe(20);\n```\n\nAnd it will remain bound, even if the right hand side becomes undefined.\n\n```javascript\nobject.right = undefined;\nexpect(object.or).toBe(20);\n```\n\n> Aside: JavaScript’s `delete` operator performs a configuration change,\n> and desugars to `Object.defineProperty`, and is not interceptable with\n> an ES5 setter.  So, don't use it on any property that is involved in a\n> binding.  Setting to null or undefined should suffice.\n\n---\n\nLogical **or** is bindable.  As with logical **and**, the binding\nperforms the minimum operation necessary to ensure that the expression\nis equal.  If the expression becomes true, and either of the operands\nare true, the nothing needs to change.  If the expression becomes false,\nhowever, both operands must be bound to false.  If the expression\nbecomes true again, it is sufficient to bind the left operand to true to\nensure that the expression as a whole is true.  Rather than belabor the\npoint, I leave as an exercise to the reader to apply DeMorgan’s Theorem\nto the documentation for logical **and** bindings.\n\n\n### Default\n\nThe **default** operator, `??`, is similar to the **or**, `||` operator,\nexcept that it decides whether to use the left or right solely based on\nwhether the left is defined.  If the left is null or undefined, the\naggregate expression will evaluate to the right expression.  If the left\nis defined, even if it is false, the result will be the left expression.\n\n```javascript\nvar object = Bindings.defineBindings({\n    left: undefined,\n    right: undefined\n}, {\n    or: {\"<-\": \"left ?? right\"}\n});\n\nobject.right = 10;\nexpect(object.or).toBe(10);\n\nobject.left = false;\nexpect(object.or).toBe(false);\n```\n\nThe default operator is not bindable, but weirder things have happened.\n\n### Defined\n\nThe `defined()` operator serves a similar role to the default operator.\nIf the value in scope is null or undefined, it the result will be false,\nand otherwise it will be true.  This will allow a term that may be\nundefined to propagate.\n\n```javascript\nvar object = Bindings.defineBindings({}, {\n    ready: {\n        \"<-\": \"value.defined()\"\n    }\n});\nexpect(object.ready).toBe(false);\n\nobject.value = 10;\nexpect(object.ready).toBe(true);\n```\n\nThe defined operator is also bindable.  If the source is or becomes\nfalse, the target will be bound to `null`.  If the source is null or\nfalse, the binding has no effect.\n\n```javascript\nvar object = Bindings.defineBindings({\n    value: 10,\n    operational: true\n}, {\n    \"value.defined()\": {\"<-\": \"operational\"}\n});\nexpect(object.value).toBe(10);\n\nobject.operational = false;\nexpect(object.value).toBe(undefined);\n```\n\nIf the source becomes null or undefined, it will cancel the previous\nbinding but does not set or restore the bound value.  Vaguely becoming\n“defined” is not enough information to settle on a particular value.\n\n```javascript\nobject.operational = true;\nexpect(object.value).toBe(undefined);\n```\n\nHowever, another binding might settle the issue.\n\n```javascript\nBindings.defineBindings(object, {\n    \"value == 10\": {\n        \"<-\": \"operational\"\n    }\n});\nexpect(object.value).toBe(10);\n```\n\n### Algebra\n\nFRB can automatically invert algebraic operators as long as they operate\nstrictly on the left-most expressions on both the source and target are\nbindable properties.\n\nIn this example, the primary binding is ```notToBe <- !toBe```, and the\ninverse binding is automatically computed ```toBe <- !notToBe```.\n\n```javascript\nvar caesar = {toBe: false};\nbind(caesar, \"notToBe\", {\"<->\": \"!toBe\"});\nexpect(caesar.toBe).toEqual(false);\nexpect(caesar.notToBe).toEqual(true);\n\ncaesar.notToBe = false;\nexpect(caesar.toBe).toEqual(true);\n```\n\nFRB does algebra by rotating the expressions on one side of a binding to\nthe other until only one independent property remains (the left most\nexpression) on the target side of the equation.\n\n```\nconvert: y <- !x\nrevert: x <- !y\n```\n\n```\nconvert: y <- x + a\nrevert: x <- y - a\n```\n\nThe left-most independent variable on the right hand side becomes the\ndependent variable on the inverted binding.  At present, this only works\nfor numbers and when the left-most expression is a bindable property\nbecause it cannot assign a new value to the literal 10.  For example,\nFRB cannot yet implicitly revert ```y <-> 10 + x```.\n\n### Literals\n\nYou may have noticed literals in the previous examples.  String literals\ntake the form of any characters between single quotes.  Any character\ncan be escaped with a back slash.\n\n```javascript\nvar object = {};\nbind(object, \"greeting\", {\"<-\": \"'Hello, World!'\"});\nexpect(object.greeting).toBe(\"Hello, World!\");\n```\n\nNumber literals are digits with an optional mantissa.\n\n```javascript\nbind(object, 'four', {\"<-\": \"2 + 2\"});\n```\n\n### Tuples\n\nBindings can produce fixed-length arrays.  These are most useful in\nconjunction with mappings.  Tuples are comma-delimited and\nparantheses-enclosed.\n\n```javascript\nvar object = {array: [[1, 2, 3], [4, 5]]};\nbind(object, \"summary\", {\"<-\": \"array.map{[length, sum()]}\"});\nexpect(object.summary).toEqual([\n    [3, 6],\n    [2, 9]\n]);\n```\n\n### Records\n\nBindings can also produce fixed-shape objects.  The notation is\ncomma-delimited, colon-separated entries, enclosed by curly-braces.\n\n```javascript\nvar object = {array: [[1, 2, 3], [4, 5]]};\nbind(object, \"summary\", {\n    \"<-\": \"array.map{{length: length, sum: sum()}}\"\n});\nexpect(object.summary).toEqual([\n    {length: 3, sum: 6},\n    {length: 2, sum: 9}\n]);\n```\n\nThe left hand side of an entry in a record is any combination of letters\nor numbers.  The right side is any expression.\n\n### Parameters\n\nBindings can also involve parameters.  The source of parameters is by\ndefault the same as the source.  The source, in turn, defaults to the\nsame as the target object.  It can be specified on the binding\ndescriptor.  Parameters are declared by any expression following a\ndollar sign.\n\n```javascript\nvar object = {a: 10, b: 20, c: 30};\nbind(object, \"foo\", {\n    \"<-\": \"[$a, $b, $c]\"},\n    parameters: object\n});\n```\n\nBindings also react to changes to the parameters.\n\n```javascript\nobject.a = 0;\nobject.b = 1;\nobject.c = 2;\nexpect(object.foo).toEqual([0, 1, 2]);\n```\n\nThe degenerate case of the property language is an empty string.  This\nis a valid property path that observes the value itself.  So, as an\nemergent pattern, a `$` expression by itself corresponds to the whole\nparameters object.\n\n```javascript\nvar object = {};\nbind(object, \"ten\", {\"<-\": \"$\", parameters: 10});\nexpect(object.ten).toEqual(10);\n```\n\n### Elements and Components\n\nFRB provides a `#` notation for reaching into the DOM for an element.\nThis is handy for binding views and models on a controller object.\n\nThe `defineBindings` method accepts an optional final argument,\n`parameters`, which is shared by all bindings (unless shadowed by a more\nspecific parameters object on an individual descriptor).\n\nThe `parameters` can include a `document`.  The `document` may be any\nobject that implements `getElementById`.\n\nAdditionally, the `frb/dom` is an experiment that monkey-patches the DOM\nto make some properties of DOM elements observable, like the `value` or\n`checked` attribute of an `input` or `textarea element`.\n\n```javascript\nvar Bindings = require(\"frb\");\nrequire(\"frb/dom\");\n\nvar controller = Bindings.defineBindings({}, {\n\n    \"fahrenheit\": {\"<->\": \"celsius * 1.8 + 32\"},\n    \"celsius\": {\"<->\": \"kelvin - 272.15\"},\n\n    \"#fahrenheit.value\": {\"<->\": \"+fahrenheit\"},\n    \"#celsius.value\": {\"<->\": \"+celsius\"},\n    \"#kelvin.value\": {\"<->\": \"+kelvin\"}\n\n}, {\n    document: document\n});\n\ncontroller.celsius = 0;\n```\n\nOne caveat of this approach is that it can cause a lot of DOM repaint\nand reflow events.  The [Montage][] framework uses a synchronized draw\ncycle and a component object model to minimize the cost of computing CSS\nproperties on the DOM and performing repaints and reflows, deferring\nsuch operations to individual animation frames.\n\nFor a future release of Montage, FRB provides an alternate notation for\nreaching into the component object model, using its deserializer.  The\n`@` prefix refers to another component by its label.  Instead of\nproviding a `document`, Montage provides a `serialization`, which in\nturn implements `getObjectForLabel`.\n\n```javascript\nvar Bindings = require(\"frb\");\n\nvar controller = Bindings.defineBindings({}, {\n\n    \"fahrenheit\": {\"<->\": \"celsius * 1.8 + 32\"},\n    \"celsius\": {\"<->\": \"kelvin - 272.15\"},\n\n    \"@fahrenheit.value\": {\"<->\": \"+fahrenheit\"},\n    \"@celsius.value\": {\"<->\": \"+celsius\"},\n    \"@kelvin.value\": {\"<->\": \"+kelvin\"}\n\n}, {\n    serializer: serializer\n});\n\ncontroller.celsius = 0;\n```\n\n### Observers\n\nFRB’s bindings use observers and binders internally.  You can create an\nobserver from a property path with the `observe` function exported by\nthe `frb/observe` module.\n\n```javascript\nvar results = [];\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo.bar\", function (value) {\n    results.push(value);\n});\n\nobject.foo.bar = 10;\nexpect(results).toEqual([10]);\n\nobject.foo.bar = 20;\nexpect(results).toEqual([10, 20]);\n```\n\nFor more complex cases, you can specify a descriptor instead of the\ncallback.  For example, to observe a property’s value *before it\nchanges*, you can use the `beforeChange` flag.\n\n```javascript\nvar results = [];\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo.bar\", {\n    change: function (value) {\n        results.push(value);\n    },\n    beforeChange: true\n});\n\nexpect(results).toEqual([10]);\n\nobject.foo.bar = 20;\nexpect(results).toEqual([10, 10]);\n\nobject.foo.bar = 30;\nexpect(results).toEqual([10, 10, 20]);\n```\n\nIf the product of an observer is an array, that array is always updated\nincrementally.  It will only get emitted once.  If you want it to get\nemitted every time its content changes, you can use the `contentChange`\nflag.\n\n```javascript\nvar lastResult;\nvar array = [[1, 2, 3], [4, 5, 6]];\nobserve(array, \"map{sum()}\", {\n    change: function (sums) {\n        lastResult = sums.slice();\n        // 1. [6, 15]\n        // 2. [6, 15, 0]\n        // 3. [10, 15, 0]\n    },\n    contentChange: true\n});\n\nexpect(lastResult).toEqual([6, 15]);\n\narray.push([0]);\nexpect(lastResult).toEqual([6, 15, 0]);\n\narray[0].push(4);\nexpect(lastResult).toEqual([10, 15, 0]);\n```\n\n### Nested Observers\n\nTo get the same effect as the previous example, you would have to nest\nyour own content change observer.\n\n```javascript\nvar i = 0;\nvar array = [[1, 2, 3], [4, 5, 6]];\nvar cancel = observe(array, \"map{sum()}\", function (array) {\n    function contentChange() {\n        if (i === 0) {\n            expect(array.slice()).toEqual([6, 15]);\n        } else if (i === 1) {\n            expect(array.slice()).toEqual([6, 15, 0]);\n        } else if (i === 2) {\n            expect(array.slice()).toEqual([10, 15, 0]);\n        }\n        i++;\n    }\n    contentChange();\n    array.addRangeChangeListener(contentChange);\n    return function cancelRangeChange() {\n        array.removeRangeChangeListener(contentChange);\n    };\n});\narray.push([0]);\narray[0].push(4);\ncancel();\n```\n\nThis illustrates one crucial aspect of the architecture.  Observers\nreturn cancelation functions.  You can also return a cancelation\nfunction inside a callback observer.  That canceler will get called each\ntime a new value is observed, or when the parent observer is canceled.\nThis makes it possible to nest observers.\n\n```javascript\nvar object = {foo: {bar: 10}};\nvar cancel = observe(object, \"foo\", function (foo) {\n    return observe(foo, \"bar\", function (bar) {\n        expect(bar).toBe(10);\n    });\n});\n```\n\n### Bindings\n\nFRB provides utilities for declaraing and managing multiple bindings on\nobjects.  The `frb` (`frb/bindings`) module exports this interface.\n\n```javascript\nvar Bindings = require(\"frb\");\n```\n\nThe `Bindings` module provides `defineBindings` and `cancelBindings`,\n`defineBinding` and `cancelBinding`, as well as binding inspector\nmethods `getBindings` and `getBinding`.  All of these take a target\nobject as the first argument.\n\nThe `Bindings.defineBinding(target, descriptors)` method returns the\ntarget object for convenience.\n\n```javascript\nvar target = Bindings.defineBindings({}, {\n    \"fahrenheit\": {\"<->\": \"celsius * 1.8 + 32\"},\n    \"celsius\": {\"<->\": \"kelvin - 272.15\"}\n});\ntarget.celsius = 0;\nexpect(target.fahrenheit).toEqual(32);\nexpect(target.kelvin).toEqual(272.15);\n```\n\n`Bindings.getBindings` in that case would return an object with\n`fahrenheit` and `celsius` keys.  The values would be identical to the\ngiven binding descriptor objects, like `{\"<->\": \"kelvin - 272.15\"}`, but\nit also gets annotated with a `cancel` function and the default values\nfor any ommitted properties like `source` (same as `target`),\n`parameters` (same as `source`), and others.\n\n`Bindings.cancelBindings` cancels all bindings attached to an object and\nremoves them from the bindings descriptors object.\n\n```javascript\nBindings.cancelBindings(target);\nexpect(Bindings.getBindings(object)).toEqual({});\n```\n\n### Binding Descriptors\n\nBinding descriptors describe the source of a binding and additional\nparameters.  `Bindings.defineBindings` can set up bindings (```<-``` or\n```<->```), computed (```compute```) properties, and falls back to\ndefining ES5 properties with permissive defaults (`enumerable`,\n`writable`, and `configurable` all on by default).\n\nIf a descriptor has a ```<-``` or ```<->```, it is a binding descriptor.\nFRB creates a binding, adds the canceler to the descriptor, and adds the\ndescriptor to an internal table that tracks all of the bindings defined\non that object.\n\n```javascript\nvar object = Bindings.defineBindings({\n    darkMode: false,\n    document: document\n}, {\n    \"document.body.classList.has('dark')\": {\n        \"<-\": \"darkMode\"\n    }\n});\n```\n\nYou can get all the binding descriptors with `Bindings.getBindings`, or a\nsingle binding descriptor with `Bindings.getBinding`.  `Bindings.cancel` cancels\nall the bindings to an object and `Bindings.cancelBinding` will cancel just\none.\n\n```javascript\n// Continued from above...\nvar bindings = Bindings.getBindings(object);\nvar descriptor = Bindings.getBinding(object, \"document.body.classList.has('dark')\");\nBindings.cancelBinding(object, \"document.body.classList.has('dark')\");\nBindings.cancelBindings(object);\nexpect(Object.keys(bindings)).toEqual([]);\n```\n\n### Converters\n\nA binding descriptor can have a `convert` function, a `revert` function,\nor alternately a `converter` object.  Converters are useful for\ntransformations that cannot be expressed in the property language, or\nare not reversible in the property language.\n\nIn this example, `a` and `b` are synchronized such that `a` is always\nhalf of `b`, regardless of which property gets updated.\n\n```javascript\nvar object = Bindings.defineBindings({\n    a: 10\n}, {\n    b: {\n        \"<->\": \"a\",\n        convert: function (a) {\n            return a * 2;\n        },\n        revert: function (b) {\n            return b / 2;\n        }\n    }\n});\nexpect(object.b).toEqual(20);\n\nobject.b = 10;\nexpect(object.a).toEqual(5);\n```\n\nConverter objects are useful for reusable or modular converter types and\nconverters that track additional state.\n\n```javascript\nfunction Multiplier(factor) {\n    this.factor = factor;\n}\nMultiplier.prototype.convert = function (value) {\n    return value * this.factor;\n};\nMultiplier.prototype.revert = function (value) {\n    return value / this.factor;\n};\n\nvar doubler = new Multiplier(2);\n\nvar object = Bindings.defineBindings({\n    a: 10\n}, {\n    b: {\n        \"<->\": \"a\",\n        converter: doubler\n    }\n});\nexpect(object.b).toEqual(20);\n\nobject.b = 10;\nexpect(object.a).toEqual(5);\n```\n\nReusable converters have an implied direction, from some source type to\na particular target type.  Sometimes the types on your binding are the\nother way around.  For that case, you can use the converter as a\nreverter.  This merely swaps the `convert` and `revert` methods.\n\n```javascript\nvar uriConverter = {\n    convert: encodeURI,\n    revert: decodeURI\n};\nvar model = Bindings.defineBindings({}, {\n    \"title\": {\n        \"<->\": \"location\",\n        reverter: uriConverter\n    }\n});\n\nmodel.title = \"Hello, World!\";\nexpect(model.location).toEqual(\"Hello,%20World!\");\n\nmodel.location = \"Hello,%20Dave.\";\nexpect(model.title).toEqual(\"Hello, Dave.\");\n```\n\n### Computed Properties\n\nA computed property is one that gets updated with a function call when\none of its arguments changes.  Like a converter, it is useful in cases\nwhere a transformation or computation cannot be expressed in the\nproperty language, but can additionally accept multiple arguments as\ninput.  A computed property can be used as the source for another\nbinding.\n\nIn this example, we create an object as the root of multiple bindings.\nThe object synchronizes the properties of a \"form\" object with the\nwindow’s search string, effectively navigating to a new page whenever\nthe \"q\" or \"charset\" values of the form change.\n\n```javascript\nBindings.defineBindings({\n    window: window,\n    form: {\n        q: \"\",\n        charset: \"utf-8\"\n    }\n}, {\n    queryString: {\n        args: [\"form.q\", \"form.charset\"],\n        compute: function (q, charset) {\n            return \"?\" + QS.stringify({\n                q: q,\n                charset: charset\n            });\n        }\n    },\n    \"window.location.search\": {\n        \"<-\": \"queryString\"\n    }\n});\n```\n\n### Debugging with Traces\n\nA binding can be configured to log when it changes and why.  The `trace`\nproperty on a descriptor instructs the binder to log changes to the\nconsole.\n\n```javascript\nBindings.defineBindings({\n    a: 10\n}, {\n    b: {\n        \"<-\": \"a + 1\",\n    }\n});\n```\n\n### Polymorphic Extensibility\n\nBindings support three levels of polymorphic extensibility depending on\nthe needs of a method that FRB does not anticipate.\n\nIf an operator is pure, meaning that all of its operands are value types\nthat will necessarily need to be replaced outright if they every change,\nmeaning that they are all effectively stateless, and if all of the\noperands must be defined in order for the output to be defined, it is\nsufficient to just use a plain JavaScript method.  For example,\n`string.toUpperCase()` will work fine.\n\nIf an operator responds to state changes of its one and only operand, an\nobject may implement an observer method.  If the operator is `foo` in\nFRB, the JavaScript method is `observeFoo(emit)`.  The observer must\nreturn a cancel function if it will emit new values after it returns, or\nif it uses observers itself.  It must stop emitting new values if FRB\ncalls its canceler.  The emitter may return a canceler itself, and the\nobserver must call that canceler before it emits a new value.\n\nThis is an example of a clock.  The `clock.time()` is an observable\noperator of the clock in FRB, implemented by `observeTime`.  It will\nemit a new value once a second.\n\n```javascript\nfunction Clock() {\n}\n\nClock.prototype.observeTime = function (emit) {\n    var cancel, timeoutHandle;\n    function tick() {\n        if (cancel) {\n            cancel();\n        }\n        cancel = emit(Date.now());\n        timeoutHandle = setTimeout(tick, 1000);\n    }\n    tick();\n    return function cancelTimeObserver() {\n        clearTimeout(timeoutHandle);\n        if (cancel) {\n            cancel();\n        }\n    };\n};\n\nvar object = Bindings.defineBindings({\n    clock: new Clock()\n}, {\n    \"time\": {\"<-\": \"clock.time()\"}\n});\n\nexpect(object.time).not.toBe(undefined);\n\nBindings.cancelBindings(object);\n```\n\nIf an operator responds to state changes of its operands, you will need\nto implement an observer maker.  An observer maker is a function that\nreturns an observer function, and accepts observer functions for all of\nthe arguments you are expected to observe.  The observer must also\nhandle a scope argument, usually just passing it on at run-time,\n`observe(emit, scope)`.  Otherwise it is much the same.\n\nFRB would delegate to `makeTimeObserver(observeResolution)` for a\n`clock.time(ms)` FRB expression.\n\nThis is an updated rendition of the clock example except that it will\nobserve changes to a resolution operand and adjust its tick frequency\naccordingly.\n\n```javascript\nfunction Clock() {\n}\n\nClock.prototype.observeTime = function (emit, resolution) {\n    var cancel, timeoutHandle;\n    function tick() {\n        if (cancel) {\n            cancel();\n        }\n        cancel = emit(Date.now());\n        timeoutHandle = setTimeout(tick, resolution);\n    }\n    tick();\n    return function cancelTimeObserver() {\n        clearTimeout(timeoutHandle);\n        if (cancel) {\n            cancel();\n        }\n    };\n};\n\nClock.prototype.makeTimeObserver = function (observeResolution) {\n    var self = this;\n    return function observeTime(emit, scope) {\n        return observeResolution(function replaceResolution(resolution) {\n            return self.observeTime(emit, resolution);\n        }, scope);\n    };\n};\n\nvar object = Bindings.defineBindings({\n    clock: new Clock()\n}, {\n    \"time\": {\"<-\": \"clock.time(1000)\"}\n});\n\nexpect(object.time).not.toBe(undefined);\n\nBindings.cancelBindings(object);\n```\n\nPolymorphic binders are not strictly impossible, but you would be mad to\ntry them.\n\n\n## Reference\n\nFunctional Reactive Bindings is an implementation of synchronous,\nincremental object-property and collection-content bindings for\nJavaScript.  It was ripped from the heart of the [Montage][] web\napplication framework and beaten into this new, slightly magical form.\nIt must prove itself worthy before it can return.\n\n-   **functional**: The implementation uses functional building blocks\n    to compose observers and binders.\n-   **generic**: The implementation uses generic methods on collections,\n    like `addRangeChangeListener`, so any object can implement the\n    same interface and be used in a binding.\n-   **reactive**: The values of properties and contents of collections\n    react to changes in the objects and collections on which they\n    depend.\n-   **synchronous**: All bindings are made consistent in the statement\n    that causes the change.  The alternative is asynchronous, where\n    changes are queued up and consistency is restored in a later event.\n-   **incremental**: If you update an array, it produces a content\n    change which contains the values you added, removed, and the\n    location of the change.  Most bindings can be updated using only\n    these values.  For example, a sum is updated by decreasing by the\n    sum of the values removed, and increasing by the sum of the values\n    added.  FRB can incrementally update `map`, `reversed`, `flatten`,\n    `sum`, and `average` observers.  It can also incrementally update\n    `has` bindings.\n-   **unwrapped**: Rather than wrap objects and arrays with observable\n    containers, FRB modifies existing arrays and objects to make them\n    dispatch property and content changes.  For objects, this involves\n    installing getters and setters using the ES5 `Object.defineProperty`\n    method.  For arrays, this involves replacing all of the mutation\n    methods, like `push` and `pop`, with variants that dispatch change\n    notifications.  The methods are either replaced by swapping the\n    `__proto__` or adding the methods to the instance with\n    `Object.defineProperties`.  These techniques should [work][Define\n    Property] starting in Internet Explorer 9, Firefox 4, Safari 5,\n    Chrome 7, and Opera 12.\n\n\n### Architecture\n\n-   [Collections][] provides **property, mapped content, and ranged\n    content change events** for objects, arrays, and other collections.\n    For objects, this adds a property descriptor to the observed object.\n    For arrays, this either swaps the prototype or mixes methods into\n    the array so that all methods dispatch change events.  \n    Caveats: you have to use a `set` method on Arrays to dispatch\n    property and content change events.  Does not work in older Internet\n    Explorers since they support neither prototype assignment or ES5\n    property setters.\n-   **observer** functions for watching an entire object graph for\n    incremental changes, and gracefully rearranging and canceling those\n    observers as the graph changes.  Observers can be constructed\n    directly or with a very small query language that compiles to a tree\n    of functions so no parsing occurs while the graph is being watched.\n-   one- and two-way **bindings** using binder and obserer functions to\n    incrementally update objects.\n-   **declarative** interface for creating an object graph with\n    bindings, properties, and computed properties with dependencies.\n\n\n### Bindings\n\nThe highest level interface for FRB resembles the ES5 Object constructor\nand can be used to declare objects and define and cancel bindings on\nthem with extended property descriptors.\n\n```javascript\nvar Bindings = require(\"frb\");\n\n// create an object\nvar object = Bindings.defineBindings({\n    foo: 0,\n    graph: [\n        {numbers: [1,2,3]},\n        {numbers: [4,5,6]}\n    ]\n}, {\n    bar: {\"<->\": \"foo\", enumerable: false},\n    numbers: {\"<-\": \"graph.map{numbers}.flatten()\"},\n    sum: {\"<-\": \"numbers.sum()\"},\n    reversed: {\"<-\": \"numbers.reversed()\"}\n});\n\nexpect(object.bar).toEqual(object.foo);\nobject.bar = 10;\nexpect(object.bar).toEqual(object.foo);\nexpect.foo = 20;\nexpect(object.bar).toEqual(object.foo);\n\n// note that the identity of the bound numbers array never\n// changes, because all of the changes to that array are\n// incrementally updated\nvar numbers = object.numbers;\n\n// first computation\nexpect(object.sum).toEqual(21);\n\n// adds an element to graph,\n// which pushes [7, 8, 9] to \"graph.map{numbers}\",\n// which splices [7, 8, 9] to the end of\n//  \"graph.map{numbers}.flatten()\",\n// which increments \"sum()\" by [7, 8, 9].sum()\nobject.graph.push({numbers: [7, 8, 9]});\nexpect(object.sum).toEqual(45);\n\n// splices [1] to the beginning of [1, 2, 3],\n// which splices [1] to the beginning of \"...flatten()\"\n// which increments \"sum()\" by [1].sum()\nobject.graph[0].numbers.unshift(1);\nexpect(object.sum).toEqual(46);\n\n// cancels the entire observer hierarchy, then attaches\n//  listeners to the new one.  updates the sum.\nobject.graph = [{numbers: [1,2,3]}];\nexpect(object.sum).toEqual(6);\n\nexpect(object.reversed).toEqual([3, 2, 1]);\n\nexpect(object.numbers).toBe(numbers) // still the same object\n\nBindings.cancelBindings(object); // cancels all bindings on this object and\n// their transitive observers and event listeners as deep as\n// they go\n```\n\n-   `Bindings.defineBindings(object, name, descriptor)`\n-   `Bindings.defineBinding(object, name, descriptor)`\n-   `Bindings.getBindings(object)`\n-   `Bindings.getBinding(object, name)`\n-   `Bindings.cancelBindings(object)`\n-   `Bindings.cancelBinding(object, name)`\n\nA binding descriptor contains:\n\n-   `target`: the\n-   `targetPath`: the target\n-   `targetSyntax`: the syntax tree for the target path\n-   `source`: the source object, which defaults to `target`\n-   `sourcePath`: the source path, from either ```<-``` or ```<->```\n-   `sourceSyntax`: the syntax tree for the source path\n-   `twoWay`: whether the binding goes in both directions, if ```<->```\n    was the source path.\n-   `parameters`: the parameters, which default to `source`.\n-   `convert`: a function that converts the source value to the target\n    value, useful for coercing strings to dates, for example.\n-   `revert`: a function that converts the target value to the source\n    value, useful for two-way bindings.\n-   `converter`: an object with `convert` and optionally also a `revert`\n    method.  The implementation binds these methods to their converter\n    and stores them in `covert` and `revert`.\n-   `serializable`: a note from the Montage Deserializer, to the [Montage\n    Serializer][], indicating that the binding came from a\n    serialization, and to a serialization it must return.\n-   `cancel`: a function to cancel the binding\n\n[Montage Serializer]: https://github.com/montagejs/mousse\n\n### Bind\n\nThe `bind` module provides direct access to the `bind` function.\n\n```javascript\nvar bind = require(\"frb/bind\");\n\nvar source = [{numbers: [1,2,3]}, {numbers: [4,5,6]}];\nvar target = {};\nvar cancel = bind(target, \"summary\", {\n    \"<-\": \"map{[numbers.sum(), numbers.average()]}\",\n    source: source\n});\n\nexpect(target.summary).toEqual([\n    [6, 2],\n    [15, 5]\n]);\n\ncancel();\n```\n\n`bind` is built on top of `parse`, `compileBinder`, and\n`compileObserver`.\n\n### Compute\n\nThe `compute` module provides direct access to the `compute` function,\nused by `Bindings` to make computed properties.\n\n```javascript\nvar compute = require(\"frb/compute\");\n\nvar source = {operands: [10, 20]};\nvar target = {};\nvar cancel = compute(target, \"sum\", {\n    source: source,\n    args: [\"operands.0\", \"operands.1\"],\n    compute: function (a, b) {\n        return a + b;\n    }\n});\n\nexpect(target.sum).toEqual(30);\n\n// change one operand\nsource.operands.set(1, 30); // needed to dispatch change notification\nexpect(target.sum).toEqual(40);\n```\n\n### Observe\n\nThe `observe` modules provides direct access to the `observe` function.\n`observe` is built on top of `parse` and `compileObserver`.\n`compileObserver` creates a tree of observers using the methods in the\n`observers` module.\n\n```javascript\nvar observe = require(\"frb/observe\");\n\nvar source = [1, 2, 3];\nvar sum;\nvar cancel = observe(source, \"sum()\", function (newSum) {\n    sum = newSum;\n});\n\nexpect(sum).toBe(6);\n\nsource.push(4);\nexpect(sum).toBe(10);\n\nsource.unshift(0); // no change\nexpect(sum).toBe(10);\n\ncancel();\nsource.splice(0, source.length); // would change\nexpect(sum).toBe(10);\n```\n\n`observe` produces a cancelation hierarchy.  Each time a value is\nremoved from an array, the underlying observers are canceled.  Each time\na property is replaced, the underlying observer is canceled.  When new\nvalues are added or replaced, the observer produces a new canceler.  The\ncancel function returned by `observe` commands the entire underlying\ntree.\n\nObservers also optional accept a descriptor argument in place of a\ncallback.\n\n-   `set`: the change handler, receives `value` for most observers, but\n    also `key` and `object` for property changes.\n-   `parameters`: the value for `$` expressions.\n-   `beforeChange`: instructs an observer to emit the previous value\n    before a change occurs.\n-   `contentChange`: instructs an observer to emit an array every time\n    its content changes.  By default, arrays are only emitted once.\n\n```javascript\nvar object = {};\nvar cancel = observe(object, \"array\", {\n    change: function (value) {\n        // may return a cancel function for a nested observer\n    },\n    parameters: {},\n    beforeChange: false,\n    contentChange: true\n});\n\nobject.array = []; // emits []\nobject.array.push(10); // emits [10]\n```\n\n### Evaluate\n\nThe `compile-evaluator` module returns a function that accepts a syntax\ntree and returns an evaluator function.  The evaluator accepts a scope\n(which may include a value, parent scope, parameters, a document, and\ncomponents) and returns the corresponding value without all the cost or\nbenefit of setting up incremental observers.\n\n```javascript\nvar parse = require(\"frb/parse\");\nvar compile = require(\"frb/compile-evaluator\");\nvar Scope = require(\"frb/scope\");\n\nvar syntax = parse(\"a.b\");\nvar evaluate = compile(syntax);\nvar c = evaluate(new Scope({a: {b: 10}}))\nexpect(c).toBe(10);\n```\n\nThe `evaluate` module returns a function that accepts a path or syntax\ntree, a source value, and parameters and returns the corresponding\nvalue.\n\n```javascript\nvar evaluate = require(\"frb/evaluate\");\nvar c = evaluate(\"a.b\", {a: {b: 10}})\nexpect(c).toBe(10);\n```\n\n\n### Stringify\n\nThe `stringify` module returns a function that accepts a syntax tree and\nreturns the corresponding path in normal form.\n\n```javascript\nvar stringify = require(\"frb/stringify\");\n\nvar syntax = {type: \"and\", args: [\n    {type: \"property\", args: [\n        {type: \"value\"},\n        {type: \"literal\", value: \"a\"}\n    ]},\n    {type: \"property\", args: [\n        {type: \"value\"},\n        {type: \"literal\", value: \"b\"}\n    ]}\n]};\n\nvar path = stringify(syntax);\nexpect(path).toBe(\"a && b\");\n```\n\n\n### Grammar\n\nThe grammar is expressed succinctly in `grammar.pegjs` and is subject to\nammendment.\n\n### Semantics\n\nAn expression is observed with a source value and emits a target\none or more times.  All expressions emit an initial value.  Array\ntargets are always updated incrementally.  Numbers and boolean are\nemited anew each time their value changes.\n\nIf any operand is `null` or `undefine`, a binding will not emit an\nupdate.  Thus, if a binding’s source becomes invalid, it does not\ncorrupt its target but waits until a valid replacement becomes\navailable.\n\n-   Literals are interpreted as their corresponding value.\n-   Value terms provide the source.\n-   Parameters terms provide the parameters.\n-   In a path-expression, the first term is evaluated with the source\n    value.\n-   Each subsequent term of a path expression uses the target of the\n    previous as its source.\n-   A property-expression or variable-property-expression observes the\n    key of the source object using `Object.addPropertyChangeListener`.\n-   An element identifier (with the `#` prefix) uses the `document`\n    property of the `parameters` object and emits\n    `document.getElementById(id)`, or dies trying.  Changes to the\n    document are not observed.\n-   A component label (with the `@` prefix) uses the `serialization`\n    property of `parameters` object and emits\n    `serialization.getObjectForLable(label)`, or dies trying.  Changes\n    to the serialization are not observed.  This syntax exists to\n    support [Montage][] serializations.\n-   A \"parent\" scope operator, `^` observes the given expression in the\n    context of the current scope's parent.\n-   A \"with\" scope operator, e.g., `context.(expression)`, observes the\n    given expression in a new scope that uses the `context` as its value\n    and the current scope as its parent.\n-   A \"map\" block observes the source array and emits a target array.\n    The target array is emitted once and all subsequent updates are\n    reflected as content changes that can be independently observed with\n    `addRangeChangeListener`.  Each element of the target array\n    corresponds to the observed value of the block expression using the\n    respective element in the source array as the source value.\n-   A \"map\" function call receives a function as its argument rather\n    than a block.\n-   A \"filter\" block observes the source array and emits a target array\n    containing only those values from the source array that actively\n    pass the predicate described in the block expression useing the\n    respective element in the source array as the source value.  As with\n    \"map\", filters update the target array incrementally.\n-   A \"some\" block observes whether any of the values in the source\n    collection meet the given criterion.\n-   A \"every\" block observes whether all of the values in the source\n    collection meet the given criterion.\n-   A \"sorted\" block observes the sorted version of an array, by a\n    property of each value described in the block, or itself if empty.\n    Sorted arrays are incrementally updating as values are added and\n    deleted from the source.\n-   A \"sortedSet\" block observes a collection that emits range change\n    events, by way of a property of each value described in the block,\n    or itself if empty, emitting a `SortedSet` value exactly once.  If\n    the input is or becomes invalid, the sorted set is cleared, not\n    replaced.  The sorted set will always contain the last of each group\n    of equivalant values from the input.\n-   A \"min\" block observes the which of the values in a given collection\n    produces the smallest value through the given relation.\n-   A \"max\" block observes the which of the values in a given collection\n    produces the largest value through the given relation.\n-   A \"group\" block observes which values belong to corresponding\n    equivalence classes as determined by the result of a given\n    expression on each value.  The observer is responsible for adding\n    and removing classes as they are populated and depopulated.  Each\n    class tracks the key (result of the block expression for every\n    member of a class), and an the values of the corresponding class as\n    an array.  Values are added to the end of each array as they are\n    discovered.\n-   Any function call with a \"block\" implies calling the function on the\n    result of a \"map\" block.\n-   A \"flatten\" function call observes a source array and produces a\n    target array.  The source array must only contain inner arrays.  The\n    target array is emitted once and all subsequent updates can be\n    independently observed with `addRangeChangeListener`.  The target\n    array will always contain the concatenation of all of the source\n    arrays.  Changes to the inner and outer source arrays are reflected\n    with incremental splices to the target array in their corresponding\n    positions.\n-   A \"concat\" function call observes a source array and all of its\n    argument arrays and effectively flattens all of these arrays.\n-   A \"reversed\" function call observes the source array and produces a\n    target array that contains the elements of the source array in\n    reverse order.  The target is incrementally updated.\n-   An \"enumerate\" expression observes [key, value] pairs from an array.\n    The output array of arrays is incrementally updated with range\n    changes from the source.\n-   A \"view\" function call observes a sliding window from the source,\n    from a start index (first argument) of a certain length (second\n    argument).  The source can be any collection that dispatches range\n    changes and the output will be an array of the given length.\n-   A \"sum\" function call observes the numeric sum of the source array.\n    Each alteration to the source array causes a new sum to be emitted,\n    but the sum is computed incrementally by observing the smaller sums\n    of the spliced values, added and removed.\n-   An \"average\" function call observes the average of the input values,\n    much like \"sum\".\n-   A \"last\" function call observes the last of the input values, if\n    there is one.  It does this by watching range changes that overlap\n    the last entry of the collection and emitting the new last value\n    when necessary, or undefined if the collection becomes empty.\n-   An \"only\" function call observes the only value of the input values,\n    if there is only one such value.  If there are none or more than\n    one, the only function emits undefined.\n-   A \"one\" function call observes one of the values from a collection,\n    if there is one.  Otherwise it is undefined.  The collection is at\n    liberty to determine whatever value it can most quickly and sensibly\n    provide.\n-   A \"round\" function call observes the nearest integer to the input\n    value, rounding `0.5` toward infinity.\n-   A \"floor\" function call observes the nearest integer to the input\n    value toward -infinity;\n-   A \"ceil\" function call observes the nearest integer to the input\n    value toward infinity;\n-   A \"has\" function call observes the source collection for whether it\n    contains an observed value.\n-   A \"tuple\" expression observes a source value and emits a single\n    target array with elements corresponding to the respective\n    expression in the tuple.  Each inner expression is evaluated with\n    the same source value as the outer expression.\n-   A \"startsWith\" function call observes whether the left string\n    starts with the right string.\n-   An \"endsWith\" function call observes whether the right string\n    ends with the right string.\n-   A \"contains\" function call observes whether the left string contains\n    the right string.\n-   A \"join\" function observes the left array joined by the right\n    delimiter, or an empty string.   This is not an incremental\n    operation.\n-   A \"split\" function observes the left string broken into an array\n    between the right delimiter, or an empty string.  This is not an\n    incremental operation.\n-   A \"range\" function call observes an array with the given length\n    containing sequential numbers starting with zero.  The output array\n    is updated incrementally and will dispatch one range change each\n    time the size changes by any difference.\n-   A \"keys\" function call observes an incrementally updated array of\n    the keys that a given map contains.  The keys are maintained in\n    insertion order.\n-   A \"values\" function call observes an incrementally updated array of\n    the values that a given map contains.  The values are maintained in\n    insertion order.\n-   An \"entries\" function call observes an incrementally updated array\n    of [key, value] pairs from a given mapping.  The entries are\n    retained in insertion order.\n\nUnary operators:\n\n-   \"number\" coerces the value to a number.\n-   \"neg\" converts a number to its negative.\n-   \"not\" converts a boolean  to its logical opposite, treating null or\n    undefined as false.\n\nBinary operators:\n\n-   \"add\" adds the left to the right\n-   \"sub\" subtracts the right from the left\n-   \"mul\" multiples the left to the right\n-   \"div\" divides the left by the right\n-   \"mod\" produces the left modula the right.  This is proper modula,\n    meaning a negative number that does not divide evenly into a\n    positive number will produce the difference between that number and\n    the next evenly divisible number in direction of negative infinity.\n-   \"rem\" produces the remainder of dividing the left by the right.  If\n    the left does not divide evenly into the right it will produce the\n    difference between that number and the next evenly divisible number\n    in the direction of zero.  That is to say, `rem` can produce\n    negative numbers.\n-   \"pow\" raises the left to the power of the right.\n-   \"root\" produces the \"righth\" root of the left.\n-   \"log\" produces the logarithm of the left on the right base.\n-   \"lt\" less than, as determined with `Object.compare(left, right) <\n    0`.\n-   \"le\" less than or equal, as determined with `Object.compare(left,\n    right) <= 0`.\n-   \"gt\" greater than, as determined with `Object.compare(left, right) >\n    0`.\n-   \"ge\" greater than or equal, as determined with `Object.compare(left,\n    right) >= 0`.\n-   \"compare\" as determined by `Object.compare(left, right)`.\n-   \"equals\" whether the left is equal to the right as determined by\n    `Object.equals(left, right)`.\n-   *Note: there is no \"not equals\" syntax node. The `!=` operator gets\n    converted into a \"not\" node around an \"equals\" node.\n-   \"and\" logical union, or short circuit on false\n-   \"or\" logical intersection, or short circuit on true\n\nTernary operator:\n\n-   \"if\" observes the condition (first argument, expression before the\n    `?`).  If the expression is true, the result observes the consequent\n    expression (second argument, between the question mark and the\n    colon), and if it is false, the result observes the alternate (the\n    third argument, after the colon).  If the condition is null or\n    undefined, the result is null or undefined.\n\nOn the left hand side of a binding, the last term has alternate\nsemantics.  Binders receive a target as well as a source.\n\n-   A \"with\" binding takes a \"context\" and \"expression\" argument from\n    the target, and a \"value\" expression from the source.  If and when\n    the context is or becomes defined, the binder creates a child scope\n    with the context as its value and binds the expression in that scope\n    to the source in its own.\n-   A \"parent\" binding takes an \"expression\" argument from the target,\n    and a \"value\" expression from the source.  If and when there is a\n    parent scope, and if and when there is or becomes a value in that\n    scope, the binder establishes a binding from the source expression\n    to the target expression in the parent scope.\n-   A \"property\" observes an object and a property name from the target,\n    and a value from the source.  When any of these change, the binder\n    upates the value for the property name of the object.\n-   A \"get\" observes a collection and a key from the target, and a value\n    from the source.  When any of these change, the binder updates the\n    value for the key on the collection using `collection.set(key,\n    value)`.  This is suitable for arrays and custom map\n    [Collections][].\n-   A \"equals\" expression observes a boolean value from the source.  If\n    that boolean becomes true, the equality expression is made true by\n    assigning the right expression to the left property of the equality,\n    turning the \"equals\" into an \"assign\" conceptually.  No action is\n    taken if the boolean becomes false.\n-   A \"reversed\" expression observes an indexed collection and maintains\n    a mirror array of that collection.\n-   A \"has\" function call observes a boolean value from the source, and\n    an collection and a sought value from the target.  When the value is\n    true and the value is absent in the collection, the binder uses the\n    `add` method of the collection (provided by a shim for arrays) to\n    make it true that the collection contains the sought value.  When\n    the value is false and the value does appear in the collection one\n    or more times, the binder uses the `delete` or `remove` method of\n    the collection to remove all occurrences of the sought value.\n-   An \"only\" function call binder observes a boolean value from the\n    source.  If the source value and target collection are both defined,\n    the binder ensures that the source is the only value in the target\n    collection.  The target collection may have the ranged collection\n    interface (`has` and `swap`) or it may have the set collection\n    interface (`has`, `clear`, and `add`), and the binder prefers the\n    former if both are supported because it results in a single range\n    change dispatch on the target collection.\n-   An \"if\" binding observes the condition and binds the target either\n    to the consequent or alternate.  If the condition is null or\n    undefined, the target is not bound.\n-   For an \"everyBlock\" binding, the first argument of the target\n    expression is the \"collection\", the second argument is the \"block\"\n    expression, and the source is the \"guard\".  If and when the guard is\n    or becomes true, the binder maintains a child scope for every value\n    in the collection and binds the \"block\" in that scope to be true.\n    If the guard is or becomes false, all of these bindings are\n    canceled.  When the \"guard\" is false, the every block produces no\n    bindings, and when the \"guard\" becomes false, no state is modified.\n-   For a \"someBlock\" binding, the first argument of the target\n    expression is the \"collection\", the second argument is the \"block\"\n    expression, and the source is the \"guard\".  If and when the guard is\n    or becomes false, the binder maintains a child scope for every value\n    in the collection and binds the \"block\" in that scope to be false.\n    If the guard is or becomes true, all of these bindings are canceled.\n    When the \"guard\" is true, the every block produces no bindings, and\n    when the \"guard\" becomes true, no state is modified.\n-   The \"and\" operator validates the logical expression by binding the\n    operands.  If the source expression is true, both the left and right\n    argument expressions are bound to true.  If the source expression is\n    false, and the right operand is false, the binding does nothing.  If\n    the source expression is false and the right operand is true, the\n    left operand is bound to false.\n-   The \"or\" operator validates the logical expression by binding the\n    operands.  If the source expression is false, both the left and\n    right argument expressions are bout to false.  If the source\n    expression is true, and the right operand is true, the binding does\n    nothing.  If the source expression is true and the right operand is\n    false, the left operand is bound to false.\n-   The \"rangeContent\" binding guarantees that the ranged content (as in\n    subarrays) of the target will be bound to the content of the source,\n    if both are defined, but will not replace the target collection.\n    This is useful for ensuring that a property collection with\n    important event listeners is never replaced if the bound source is\n    replaced.  The source collection must implement range change\n    dispatch, like Array, Set, List, and SortedSet.\n-   The \"mapContent\" binding guarantees that the map content of the\n    target will be bound to the content of the source, if both are\n    defined, but will not replace the target map.  This is useful for\n    ensuring that a map property with important event listeners is never\n    replaced if the bound source is replaced.   The source collection\n    must implement map change dispatch, like Map, Dict, and SortedMap.\n\n### Language Interface\n\n```javascript\nvar parse = require(\"frb/parse\");\nvar compileObserver = require(\"frb/compile-observer\");\nvar compileBinder = require(\"frb/compile-binder\");\n```\n\n-   `parse(text)` returns a syntax tree.\n-   `compileObserver(syntax)` returns an observer function of the form\n    `observe(callback, source, parameters)` which in turn returns a\n    `cancel()` function.  `compileObserver` visits the syntax tree and\n    creates functions for each node, using the `observers` module.\n-   `compileBinder(syntax)` returns a binder function of the form\n    `bind(observeValue, source, target, parameters)` which in turn\n    returns a `cancel()` function.  `compileBinder` visits the root node\n    of the syntax tree and delegates to `compileObserver` for its terms.\n    The root node must be a `property` at this time, but could\n    conceivably be any function with a clear inverse operation like\n    `map` and `reversed`.\n\n### Syntax Tree\n\nThe syntax tree is JSON serializable and has a \"type\" property.  Nodes\nhave the following types:\n\n-   `value` corresponds to observing the source value\n-   `parameters` corresponds to observing the parameters object\n-   `literal` has a `value` property and observes that value\n-   `element` has an `id` property and observes an element from the\n    `parameters.document`, by way of `getElementById`.\n-   `component` has a `label` property and observes a component from the\n    `parameters.serialization`, by way of `getObjectForLabel`.  This\n    feature support's [Montage][]’s serialization format.\n\nAll other node types have an \"args\" property that is an array of syntax\nnodes (or an \"args\" object for `record`).\n\n-   `property`: corresponds to observing a property named by the right\n    argument of the left argument.\n-   `get`: corresponds to observing the value for a key (second\n    argument) in a collection (first argument).\n-   `with`: corresponds to observing the right expression using the left\n    expression as the source.\n-   `parent`: corresponds to observing the given expression (only\n    argument) in the parent scope.\n-   `has`: corresponds to whether the key (second argument) exists\n    within a collection (first argument)\n-   `mapBlock`: the left is the input, the right is an expression to\n    observe on each element of the input.\n-   `filterBlock`: the left is the input, the right is an expression to\n    determine whether the result is included in the output.\n-   `someBlock`: the left is the input, the right is a criterion.\n-   `everyBlock`: the left is the input, the right is a criterion.\n-   `sortedBlock`: the left is the input, the right is a relation on\n    each value of the input on which to compare to determine the order.\n-   `sortedSetBlock`: differs only in semantics from `sortedBlock`.\n-   `minBlock`: the left is the input, the right is a relation on each\n    value of the input by which to compare the value to others.\n-   `maxBlock`: the left is the input, the right is a relation on each\n    value of the input by which to compare the value to others.\n-   `groupBlock`: the left is the input, the right is an expression that\n    provides the key for an equivalence class for each value in the\n    input.  The output is an array of entries, `[key, class]`, with the\n    shared key of every value in the equivalence class.\n-   `groupMapBlock`: has the same input semantics as `groupBlock`, but\n    the output is a `Map` instance instead of an array of entries.\n-   `tuple`: has any number of arguments, each an expression to observe\n    in terms of the source value.\n-   `record`: as an args object. The keys are property names for the\n    resulting object, and the values are the corresponding syntax nodes\n    for the values.\n-   `view`: the arguments are the input, the start position, and the\n    length of the sliding window to view from the input.  The input may\n    correspond to any ranged content collection, like an array or sorted\n    set.\n-   `rangeContent`: corresponds to the content of an ordered collection\n    that can dispatch indexed range changes like an array or sorted set.\n    This indicates to a binder that it should replace the content of the\n    target instead of replacing the target property with the observed\n    content of the source.  A range content node has no effect on the\n    source.\n-   `mapContent`: corresponds to the content of a map-like collection\n    including arrays and all map [Collections][].  These collections\n    dispatch map changes, which create, read, update, or delete\n    key-to-value pairs.  This indicates to a binder to replace the\n    content of the target map-like collection with the observed content\n    of the source, instead of replacing the target collection.  A map\n    change node on the source side just passes the collection forward\n    without alteration.\n\nFor all operators, the \"args\" property are operands.  The node types for\nunary operators are:\n\n-   ```+```: `number`, arithmetic coercion\n-   ```-```: `neg`, arithmetic negation\n-   ```!```: `not`, logical negation\n\nFor all binary operators, the node types are:\n\n-   ```**```: `pow`, exponential power\n-   ```//```: `root`, of 2 square root, of 3 cube root, etc\n-   ```%%```: `log`, logarithm with base\n-   ```*```: `mul`, multiplication\n-   ```/```: `div`, division\n-   ```%```: `mod`, modulo (toward negative infinity, always positive)\n-   ```rem```: `rem`, remainder (toward zero, negative if negative)\n-   ```+```: `add`, addition\n-   ```-```: `sub`, subtraction\n-   ```<```: `lt`, less than\n-   ```<=```: `le`, less than or equal\n-   ```>```: `gt`, greater than\n-   ```>=```: `ge`, greater than or equal\n-   ```<=>```: `compare`\n-   ```==```: ``equals``, equality comparison and assignment\n-   ```!=``` produces unary negation and equality comparison or\n    assignment so does not have a corresponding node type.  The\n    simplification makes it easier to rotate the syntax tree\n    algebraically.\n-   ```&&```, `and`, logical and\n-   ```||```, `or`, logical or\n-   ```??```, `default`\n\nFor the ternary operator:\n\n-   ```?``` and ```:```: `if`, ternary conditional\n\nFor all function calls, the right hand side is a tuple of arguments.\n\n-   `reversed()`\n-   `enumerate()`\n-   `flatten()`\n-   `sum()`\n-   `average()`\n-   `last()`\n-   `only()`\n-   `one()`\n-   `startsWith(other)`\n-   `endsWith(other)`\n-   `contains(other)`\n-   `join(delimiter)`\n-   `split(delimiter)`\n-   `concat(...arrays)`\n-   `range()`\n-   `keys()`\n-   `values()`\n-   `entries()`\n-   `defined()`\n-   `round()`\n-   `floor()`\n-   `ceil()`\n\n### Observers and Binders\n\nThe `observers` module contains functions for making all of the\ndifferent types of observers, and utilities for creating new ones.\nAll of these functions are or return an observer function of the form\n`observe(emit, value, parameters)` which in turn returns `cancel()`.\n\n-   `observeValue`\n-   `observeParameters`\n-   `makeLiteralObserver(value)`\n-   `makeElementObserver(id)`\n-   `makeComponentObserver(label)`\n-   `makeRelationObserver(callback, thisp)` is unavailable through the\n    property binding language, translates a value through a JavaScript\n    function.\n-   `makeComputerObserver(observeArgs, compute, thisp)` applies\n    arguments to the computation function to get a new value.\n-   `makeConverterObserver(observeValue, convert, thisp)` calls the\n    converter function to transform a value to a converted value.\n-   `makePropertyObserver(observeObject, observeKey)`\n-   `makeGetObserver(observeCollection, observeKey)`\n-   `makeMapFunctionObserver(observeArray, observeFunction)`\n-   `makeMapBlockObserver(observeArray, observeRelation)`\n-   `makeFilterBlockObserver(observeArray, observePredicate)`\n-   `makeSortedBlockObserver(observeArray, observeRelation)`\n-   `makeEnumerationObserver(observeArray)`\n-   `makeFlattenObserver(observeOuterArray)`\n-   `makeTupleObserver(...observers)`\n-   `makeObserversObserver(observers)`\n-   `makeReversedObserver(observeArrayh)`\n-   `makeWindowObserver` is not presently available through the language\n    and is subject to change.  It is for watching a length from an array\n    starting at an observable index.\n-   `makeSumObserver(observeArray)`\n-   `makeAverageObserver(observeArray)`\n-   `makeParentObserver(observeExpression)`\n-   *etc*\n\nThese are utilities for making observer functions.\n\n-   `makeNonReplacing(observe)` accepts an array observer (the emitted\n    values must be arrays) and returns an array observer that will only\n    emit the target once and then incrementally update that target.  All\n    array observers use this decorator to handle the case where the\n    source value gets replaced.\n-   `makeArrayObserverMaker(setup)` generates an observer that uses an\n    array as its source and then incrementally updates a target value,\n    like `sum` and `average`.  The `setup(source, emit)` function must\n    return an object of the form `{contentChange, cancel}` and arrange\n    for `emit` to be called with new values when `contentChange(plus,\n    minus, index)` receives incremental updates.\n-   `makeUniq(callback)` wraps an emitter callback such that it only\n    forwards new values.  So, if a value is repeated, subsequent calls\n    are ignored.\n-   `autoCancelPrevious(callback)` accepts an observer callback and\n    returns an observer callback.  Observer callbacks may return\n    cancelation functions, so this decorator arranges for the previous\n    canceler to be called before producing a new one, and arranges for\n    the last canceler to be called when the whole tree is done.\n-   `once(callback)` accepts a canceler function and ensures that the\n    cancelation routine is only called once.\n\nThe `binders` module contains similar functions for binding an observed\nvalue to a bound value.  All binders are of the form `bind(observeValue,\nsource, target, parameters)` and return a `cancel()` function.\n\n-   `makePropertyBinder(observeObject, observeKey)`\n-   `makeGetBinder(observeCollection, observeKey)`\n-   `makeHasBinder(observeCollection, observeValue)`\n-   `makeEqualityBinder(observeLeft, observeRight)`\n-   `makeRangeContentBinder(observeTarget)`\n-   `makeMapContentBinder(observeTarget)`\n-   `makeReversedBinder(observeTarget)`\n\nThis documentation of the internal observer and binder functions is not\nexhaustive.\n\n[Collections]: https://github.com/montagejs/collections\n[Define Property]: http://kangax.github.com/es5-compat-table/#define-property-webkit-note\n[Montage]: https://github.com/montagejs/montage\n[Mr]: https://github.com/montagejs/mr\n[Mutation Observers]: https://developer.mozilla.org/en-US/docs/DOM/DOM_Mutation_Observers\n[Node.js]: http://nodejs.org/\n\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/kriskowal/frb",
  "_id": "frb@0.2.18",
  "_from": "frb@~0.2.17"
}
