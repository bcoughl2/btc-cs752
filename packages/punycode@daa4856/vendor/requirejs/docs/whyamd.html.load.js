montageDefine("daa4856","vendor/requirejs/docs/whyamd.html",{text:'<html><head></head><body><div id=directory class=section>\n<h1>Why AMD?</h1>\n\n<ul class="index mono">\n    <li class=hbox>\n        <a href=#purposes>Module Purposes</a><span class="spacer boxFlex"></span><span class=sect>§ 1</span>\n    </li>\n    <li class=hbox>\n        <a href=#today>The Web Today</a><span class="spacer boxFlex"></span><span class=sect>§ 2</span>\n    </li>\n    <li class=hbox>\n        <a href=#commonjs>CommonJS</a><span class="spacer boxFlex"></span><span class=sect>§ 3</span>\n    </li>\n    <li class=hbox>\n        <a href=#amd>AMD</a><span class="spacer boxFlex"></span><span class=sect>§ 4</span>\n    </li>\n    <li class=hbox>\n        <a href=#definition>Module Definition</a><span class="spacer boxFlex"></span><span class=sect>§ 5</span>\n    </li>\n    <li class=hbox>\n        <a href=#namedmodules>Named Modules</a><span class="spacer boxFlex"></span><span class=sect>§ 6</span>\n    </li>\n    <li class=hbox>\n        <a href=#sugar>Sugar</a><span class="spacer boxFlex"></span><span class=sect>§ 7</span>\n    </li>\n    <li class=hbox>\n        <a href=#commonjscompat>CommonJS Compatibility</a><span class="spacer boxFlex"></span><span class=sect>§ 8</span>\n    </li>\n    <li class=hbox>\n        <a href=#amdtoday>AMD Used Today</a><span class="spacer boxFlex"></span><span class=sect>§ 9</span>\n    </li>\n    <li class=hbox>\n        <a href=#youcando>What You Can Do</a><span class="spacer boxFlex"></span><span class=sect>§ 10</span>\n    </li>\n</ul>\n\n<p>This page talks about the design forces and use of the\n<a href=https://github.com/amdjs/amdjs-api/wiki/AMD>Asynchronous Module Definition (AMD) API</a> for JavaScript modules, the module API supported by RequireJS.\nThere is a different page that talks about <a href=why.html>general approach to modules on the web</a>.</p>\n\n</div>\n\n\n<div class=section>\n<h2>\n<a href=#purposes name=purposes>Module Purposes</a>\n<span class=sectionMark>§ 1</span>\n</h2>\n\n<p>What are JavaScript modules? What is their purpose?</p>\n\n<ul>\n<li><strong>Definition</strong>: how to encapsulate a piece of code into a useful unit, and how to register its capability/export a value for the module.</li>\n<li><strong>Dependency References</strong>: how to refer to other units of code.</li>\n</ul>\n\n</div>\n\n\n<div class=section>\n<h2>\n<a href=#today name=today>The Web Today</a>\n<span class=sectionMark>§ 2</span>\n</h2>\n\n<pre><code>(function () {\n    var $ = this.jQuery;\n\n    this.myExample = function () {};\n}());\n</code></pre>\n\n<p>How are pieces of JavaScript code defined today?</p>\n\n<ul>\n    <li>Defined via an immediately executed factory function.</li>\n    <li>References to dependencies are done via global variable names that were loaded via an HTML script tag.</li>\n    <li>The dependencies are very weakly stated: the developer needs to know the right dependency order. For instance, The file containing Backbone cannot come before the jQuery tag.</li>\n    <li>It requires extra tooling to substitute a set of script tags into one tag for optimized deployment.</li>\n</ul>\n\n<p>This can be difficult to manage on large projects, particularly as scripts start to have many dependencies in a way that may overlap and nest. Hand-writing script tags is not very scalable, and it leaves out the capability to load scripts on demand.</p>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#commonjs name=commonjs>CommonJS</a>\n<span class=sectionMark>§ 3</span>\n</h2>\n\n<pre><code>var $ = require(\'jquery\');\nexports.myExample = function () {};\n</code></pre>\n\n<p>The original <a href=http://groups.google.com/group/commonjs>CommonJS (CJS) list</a> participants decided to work out a module format that worked with today\'s JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</p>\n\n<ul>\n<li>Either use a server to translate CJS modules to something usable in the browser.</li>\n<li>Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.</li>\n</ul>\n\n<p>The CJS module format only allowed one module per file, so a "transport format" would be used for bundling more than one module in a file for optimization/bundling purposes.</p>\n\n<p>With this approach, the CommonJS group was able to work out dependency references and how to deal with circular dependencies, and how to get some properties about the current module. However, they did not fully embrace some things in the browser environment that cannot change but still affect module design:</p>\n\n<ul>\n<li>network loading</li>\n<li>inherent asynchronicity</li>\n</ul>\n\n<p>It also meant they placed more of a burden on web developers to implement the format, and the stop-gap measures meant debugging was worse. eval-based debugging or debugging multiple files that are concatenated into one file have practical weaknesses. Those weaknesses may be addressed in browser tooling some day, but the end result: using CommonJS modules in the most common of JS environments, the browser, is non-optimal today.</p>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#amd name=amd>AMD</a>\n<span class=sectionMark>§ 4</span>\n</h2>\n\n<pre><code>define([\'jquery\'] , function ($) {\n    return function () {};\n});\n</code></pre>\n\n<p>The AMD format comes from wanting a module format that was better than today\'s "write a bunch of script tags with implicit dependencies that you have to manually order" and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started. It grew out of Dojo\'s real world experience with using XHR+eval and and wanting to avoid its weaknesses for the future.</p>\n\n<p>It is an improvement over the web\'s current "globals and script tags" because:</p>\n\n<ul>\n<li>Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals.</li>\n<li>IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing. For the above code sample, the code just expects something that implements the jQuery API and behavior. It does not have to be jQuery.</li>\n<li>Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace.</li>\n<li>Clear path to defining the module value. Either use "return value;" or the CommonJS "exports" idiom, which can be useful for circular dependencies.</li>\n</ul>\n\n<p>It is an improvement over CommonJS modules because:</p>\n\n<ul>\n<li>It works better in the browser, it has the least amount of gotchas. Other approaches have problems with debugging, cross-domain/CDN usage, file:// usage and the need for server-specific tooling.</li>\n<li>Defines a way to include multiple modules in one file. In CommonJS terms, the term for this is a "transport format", and that group has not agreed on a transport format.</li>\n<li>Allows setting a function as the return value. This is really useful for constructor functions. In CommonJS this is more awkward, always having to set a property on the exports object. Node supports module.exports = function () {}, but that is not part of a CommonJS spec.</li>\n</ul>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#definition name=definition>Module Definition</a>\n<span class=sectionMark>§ 5</span>\n</h2>\n\n<p>Using JavaScript functions for encapsulation has been documented as the <a href=http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth>module pattern</a>:</p>\n\n<pre><code>(function () {\n   this.myGlobal = function () {};\n}());\n</code></pre>\n\n<p>That type of module relies on attaching properties to the global object to export the module value, and it is difficult to declare dependencies with this model. The dependencies are assumed to be immediately available when this function executes. This limits the loading strategies for the dependencies.</p>\n\n<p>AMD addresses these issues by:</p>\n\n<ul>\n<li>Register the factory function by calling define(), instead of immediately executing it.</li>\n<li>Pass dependencies as an array of string values, do not grab globals.</li>\n<li>Only execute the factory function once all the dependencies have been loaded and executed.</li>\n<li>Pass the dependent modules as arguments to the factory function.</li>\n</ul>\n\n<pre><code>//Calling define with a dependency array and a factory function\ndefine([\'dep1\', \'dep2\'], function (dep1, dep2) {\n\n    //Define the module value by returning a value.\n    return function () {};\n});\n</code></pre>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#namedmodules name=namedmodules>Named Modules</a>\n<span class=sectionMark>§ 6</span>\n</h2>\n\n<p>Notice that the above module does not declare a name for itself. This is makes the module very portable. It allows a developer to place the module in a different path to give it a different ID/name. The AMD loader will give the module an ID based on how it is referenced by other scripts.</p>\n\n<p>However, tools that combine multiple modules together for performance need a way to give names to each module in the optimized file. For that, AMD allows a string as the first argument to define():</p>\n\n<pre><code>//Calling define with module ID, dependency array, and factory function\ndefine(\'myModule\', [\'dep1\', \'dep2\'], function (dep1, dep2) {\n\n    //Define the module value by returning a value.\n    return function () {};\n}});\n</code></pre>\n\n<p>You should avoid naming modules yourself, and only place one module in a file while developing. However, for tooling and performance, a module solution needs a way to identify modules in built resources.</p>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#sugar name=sugar>Sugar</a>\n<span class=sectionMark>§ 7</span>\n</h2>\n\n<p>The above AMD example works in all browsers. However, there is a risk of mismatched dependency names with named function arguments, and it can start to look a bit strange if your module has many dependencies:</p>\n\n<pre><code>define([ "require", "jquery", "blade/object", "blade/fn", "rdapi",\n         "oauth", "blade/jig", "blade/url", "dispatch", "accounts",\n         "storage", "services", "widgets/AccountPanel", "widgets/TabButton",\n         "widgets/AddAccount", "less", "osTheme", "jquery-ui-1.8.7.min",\n         "jquery.textOverflow"],\nfunction (require,   $,        object,         fn,         rdapi,\n          oauth,   jig,         url,         dispatch,   accounts,\n          storage,   services,   AccountPanel,           TabButton,\n          AddAccount,           less,   osTheme) {\n\n});\n</code></pre>\n\n<p>To make this easier, and to make it easy to do a simple wrapping around CommonJS modules, this form of define is supported, sometimes referred to as "simplified CommonJS wrapping":</p>\n\n<pre><code>define(function (require) {\n    var dependency1 = require(\'dependency1\'),\n        dependency2 = require(\'dependency2\');\n\n    return function () {};\n});\n</code></pre>\n\n<p>The AMD loader will parse out the require(\'\') calls by using Function.prototype.toString(), then internally convert the above define call into this:</p>\n\n<pre><code>define([\'require\', \'dependency1\', \'dependency2\'], function (require) {\n    var dependency1 = require(\'dependency1\'),\n        dependency2 = require(\'dependency2\');\n\n    return function () {};\n});\n</code></pre>\n\n<p>This allows the loader to load dependency1 and dependency2 asynchronously, execute those dependencies, then execute this function.</p>\n\n<p>Not all browsers give a usable Function.prototype.toString() results. As of October 2011, the PS 3 and older Opera Mobile browsers do not. Those browsers are more likely to need an optimized build of the modules for network/device limitations, so just do a build with an optimizer that knows how to convert these files to the normalized dependency array form, like the <a href=optimization.html>RequireJS optimizer</a>.</p>\n\n<p>Since the number of browsers that cannot support this toString() scanning is very small, it is safe to use this sugared forms for all your modules, particularly if you like to line up the dependency names with the variables that will hold their module values.</p>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#commonjscompat name=commonjscompat>CommonJS Compatibility</a>\n<span class=sectionMark>§ 8</span>\n</h2>\n\n<p>Even though this sugared form is referred to as the "simplified CommonJS wrapping", it is not 100% compatible with CommonJS modules. However, the cases that are not supported would likely break in the browser anyway, since they generally assume synchronous loading of dependencies.</p>\n\n<p>Most CJS modules, around 95% based on my (thoroughly unscientific) personal experience, are perfectly compatible with the simplified CommonJS wrapping.</p>\n\n<p>The modules that break are ones that do a dynamic calculation of a dependency, anything that does not use a string literal for the require() call, and anything that does not look like a declarative require() call. So things like this fail:</p>\n\n<pre><code>//BAD\nvar mod = require(someCondition ? \'a\' : \'b\');\n\n//BAD\nif (someCondition) {\n    var a = require(\'a\');\n} else {\n    var a = require(\'a1\');\n}\n</code></pre>\n\n<p>These cases are handled by the <a href=https://github.com/amdjs/amdjs-api/wiki/require>callback-require</a>, <code>require([moduleName], function (){})</code> normally present in AMD loaders.</p>\n\n<p>The AMD execution model is better aligned with how ECMAScript Harmony modules are being specified. The CommonJS modules that would not work in an AMD wrapper will also not work as a Harmony module. AMD\'s code execution behavior is more future compatible.</p>\n\n<h2>Verbosity vs. Usefulness</h2>\n\n<p>One of the criticisms of AMD, at least compared to CJS modules, is that it requires a level of indent and a function wrapping.</p>\n\n<p>But here is the plain truth: the perceived extra typing and a level of indent to use AMD does not matter. Here is where your time goes when coding:</p>\n\n<ul>\n<li>Thinking about the problem.</li>\n<li>Reading code.</li>\n</ul>\n\n<p>Your time coding is mostly spent thinking, not typing. While fewer words are generally preferable, there is a limit to that approach paying off, and the extra typing in AMD is not that much more.</p>\n\n<p>Most web developers are use a function wrapper anyway, to avoid polluting the page with globals. Seeing a function wrapped around functionality is a very common sight and does not add to the reading cost of a module.</p>\n\n<p>There are also hidden costs with the CommonJS format:</p>\n\n<ul>\n    <li>the tooling dependency cost</li>\n    <li>edge cases that break in browsers, like cross domain access</li>\n    <li>worse debugging, a cost that continues to add up over time</li>\n</ul>\n\n<p>AMD modules require less tooling, there are fewer edge case issues, and better debugging support.</p>\n\n<p>What is important: being able to actually share code with others. AMD is the lowest energy pathway to that goal.</p>\n\n<p>Having a working, easy to debug module system that works in today\'s browsers means getting real world experience in making the best module system for JavaScript in the future.</p>\n\n<p>AMD and its related APIs, have helped show the following for any future JS module system:</p>\n\n<ul>\n<li><strong>Returning a function as the module value</strong>, particularly a constructor function, leads to better API design. Node has module.exports to allow this, but being able to use "return function (){}" is much cleaner. It means not having to get a handle on "module" to do module.exports, and it is a clearer code expression.</li>\n<li><strong>Dynamic code loading</strong> (done in AMD systems via <a href=https://github.com/amdjs/amdjs-api/wiki/require>require([], function (){}))</a> is a basic requirement. CJS talked about it, had some proposals, but it was not fully embraced. Node does not have any support for this need, instead relying on the synchronous behavior of require(\'\'), which is not portable to the web.</li>\n<li><strong><a href=http://requirejs.org/docs/plugins.html>Loader plugins</a></strong> are incredibly useful. It helps avoid the nested brace indenting common in callback-based programming.</li>\n<li><strong>Selectively mapping one module</strong> to load from another location makes it easy to provide mock objects for testing.</li>\n<li>There should only be at most <strong>one IO action for each module</strong>, and it should be straightforward. Web browsers are not tolerant of multiple IO lookups to find a module. This argues against the multiple path lookups that Node does now, and avoiding the use of a package.json "main" property. Just use module names that map easily to one location based on the project\'s location, using a reasonable default convention that does not require verbose configuration, but allow for simple configuration when needed.</li>\n<li>It is best if there is an <strong>"opt-in" call</strong> that can be done so that older JS code can partcipate in the new system.</li>\n</ul>\n\n<p>If a JS module system cannot deliver on the above features, it is at a significant disadvantage when compared to AMD and its related APIs around <a href=https://github.com/amdjs/amdjs-api/wiki/require>callback-require</a>, <a href=https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins>loader plugins</a>, and paths-based module IDs.</p>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#amdtoday name=amdtoday>AMD Used Today</a>\n<span class=sectionMark>§ 9</span>\n</h2>\n\n<p>As of mid October 2011, AMD already has good adoption on the web:</p>\n\n<ul>\n<li><a href="http://jquery.com/">jQuery</a> 1.7</li>\n<li><a href="http://dojotoolkit.org/">Dojo</a> 1.7</li>\n<li><a href="http://mootools.net/">MooTools</a> 2.0</li>\n<li><a href="http://uxebu.github.com/embedjs/">EmbedJS</a></li>\n<li><a href="http://ender.no.de/">Ender</a>-associated modules like <a href=https://github.com/ded/bonzo>bonzo</a>, <a href=https://github.com/ded/qwery>qwery</a>, <a href=https://github.com/fat/bean>bean</a> and <a href=https://github.com/ded/domready>domready</a></li>\n<li>Used by <a href="http://getfirebug.com/">Firebug</a> 1.8+</li>\n<li>The simplified CommonJS wrapper can be used in <a href="https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/">Jetpack/Add-on SDK</a> for Firefox</li>\n<li>Used for parts of sites on <a href="http://www.bbc.co.uk/">the BBC</a> (observed by looking at the source, not an official recommendation of AMD/RequireJS)</li>\n</ul>\n\n</div>\n\n<div class=section>\n<h2>\n<a href=#youcando name=youcando>What You Can Do</a>\n<span class=sectionMark>§ 10</span>\n</h2>\n\n<p id=doapp><strong>If you write applications:</strong></p>\n\n<ul>\n<li>Give an AMD loader a try. You have some choices:\n<ul>\n<li><a href=http://requirejs.org>RequireJS</a></li>\n<li><a href=https://github.com/unscriptable/curl>curl</a></li>\n<li><a href=https://github.com/zazl/lsjs>lsjs</a></li>\n<li><a href="http://dojotoolkit.org/">Dojo</a> 1.7 and <a href="http://mootools.net/">MooTools</a> 2.0 each have their own</li>\n</ul></li>\n<li>If you want to use AMD but still use the <strong>load one script at the bottom of the HTML page</strong> approach:\n<ul>\n<li>Use the <a href=http://requirejs.org/docs/optimization.html>RequireJS optimizer</a> either in command line mode or as an <a href=https://github.com/jrburke/r.js/blob/master/build/tests/http/httpBuild.js>HTTP service</a> with the <a href=https://github.com/jrburke/almond>almond AMD shim</a>.</li>\n</ul></li>\n</ul>\n\n<p id=dolib><strong>If you are a script/library author</strong>:</p>\n\n<ul>\n<li><a href=https://github.com/umdjs/umd>Optionally call define()</a> if it is available. The nice thing is you can still code your library without relying on AMD, just participate if it is available. This allows consumers of your modules to:\n<ul>\n<li>avoid dumping global variables in the page</li>\n<li>use more options for code loading, delayed loading</li>\n<li>use existing AMD tooling to optimize their project</li>\n<li>participate in a workable module system for JS in the browser today.</li>\n</ul></li>\n</ul>\n\n<p id=doenv><strong>If you write code loaders/engines/environments for JavaScript:</strong></p>\n\n<ul>\n<li>Implement <a href=https://github.com/amdjs/amdjs-api/wiki/AMD>the AMD API</a>. There is <a href=https://groups.google.com/group/amd-implement>a discussion list</a> and <a href=https://github.com/amdjs/amdjs-tests>compatibility tests</a>. By implementing AMD, you will reduce multi-module system boilerplate and help prove out a workable JavaScript module system on the web. This can be fed back into the ECMAScript process to build better native module support.</li>\n<li>Also support <a href=https://github.com/amdjs/amdjs-api/wiki/require>callback-require</a> and <a href=https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins>loader plugins</a>. Loader plugins are a great way to reduce the nested callback syndrome that can be common in callback/async-style code.</li>\n</ul>\n\n</div>\n</body></html>'});